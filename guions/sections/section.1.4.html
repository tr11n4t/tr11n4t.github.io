<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Pàgina encriptada</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Pàgina encriptada</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Contrasenya"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Recorda'm
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DESENCRIPTEU" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Contrasenya incorrecta",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"731d0736508876f0956103e51f7b622517273d7c07ccd0e78382fe102f4dc004bb13c1740e3e0b006cbcddc345d983277ebbc4cb4aa43715cf1474ec8315de9980328e5fe9ab341f1b6102a8b7061ec7a99c48c92a953761bc7ddd0f52ca3d64ad28eb65ac7a8d459a106be3a499e3d261b0efac87207537e76392984589d44b7ec7ba0167e6b2e789c9223a07bb2c6cf6c5ddb30a77c5aaa73f62c013ce279358dac3b2736467015b357dccea2b38593ec92a3691f3204c3fea1c562ad52626c124b68d4dbbd8b251c8a69f21611f17538ab499235b5358c641a893125b29ec832d3a9a2fedb617ca6d37aee58a99535c6f7fa8cf2b46a2de08e1e0cb06da77f9ecf5ae15258f2b6e09199daa8567ed215d303ba3e4ac24c649396924c48109abd1deebc0a5407b2485528ed1f74c5d2f46884ac1a42b5dbe93ed9dbc9f615b90059781fe230d07b3ecdc698feb0ee78fa8d5903f5bed2e62be8cfff7ef2aa710e2b69c5e499cd0e4a06bd5c20ef672f6893877514eb2bb8096f110f3129783d5ceac82b18e9f29306ae1c195d2446c224bef9e1ef59a6a1d5a27354450251556ca902690b4f8858678c9012f8d9d8ce59ed563441884585a00e57d3077e8e18f54f0e4346b86acc9f71c581c1d82af1a6fd1f7facfa1018cab37ac14783a7615b2c18029d176d32598a0f228b6b304158f77eb39a9ff05d30852116e7d9de9ce2226a483bf1d2dda6348813df431ac4e1e4eacbf034adfb34f42dae9999e13aab02e215da216f1721c7c46d06411c835b44ab6d65df41d7e212bba41bc5d143e64d6d82ec2d5284789174d3fcc488dcc9a0316ac351f380fa7025e479d87e1b3d29f32b5923528d1e259aa04fd3f8a7b51e9930fc7a71b91e3c5030c3922443c0b3440608f3ff1b48fe2e54eabe6ffced764e7631c8ade561f86828a3ffdae9d83a71994511d2daac5bd6bc9cc18b2253eac09f7471a32f375bfa0c3a6479a924c52306c997206e652b094da2699ce91ddf5d7329d60c3860b291d9a269bbf9b62d977c77b01ceaee7d9c0d382e44b243ca9ccf9bc691b0ec726c5c8cfe4b2a174fe324c899df83c8de000b50afcde3d36a19eaac851177686ea0eeb4a07a4d1b02db3a93587c798f8325dbf88094cd31aae4630cdd69ba27a1b05b2f9d924be0e17cfc09d8b660c09b667a0cee53b3bf77fdd2381158918dadc2f6828b72da80a7117994dc18ddae3f9fb3237b5ce0865e97096ac2ed7a3a89f99a0060fdbdcd8e53567d6bf0f6da95b1d6bc31187d04b3065c9336e166577a752a3655b1b132cb380dbc27b4abd28f776bafb413f46e462c2c2febb43c411edaf4da0330acc690cf256c96a8f7eafce6671a86586c5df096d11539798d9decd452f0f11b6d13057d8aceb7ca3d9fff0bb8c7f55175e6721c0be90876ed695f6553b8d14c00b9b52951ce14fc415d7e39fc40052301d9fa7dad7e410e6b80f834ef0205d42bfa1c08e028ae72075646e473c27ecccbaca09528d6eca9cf0123219057fd0940db37bf5e16a5f0e68a1488e4f85acc57ec4763d969eebe4247ee9ac287ae3b3c2bfc03d8aad4705dbe3b055fcb534b680d47af10384b645176d533f112ee983e1dcdcbe8d063785764c5c86835d843bd6a7174a4e256c6e26f6048eb8f58051240132f3c5765e3f1cee2ee263fb7c78b473152b257d748a2426dc91bf2686002dddc2180fb9da87e674e7853006f874fe0bea37e32eac59a52f36edabffafcff30a9ff846087ef3305f3d3fd940b00a144bbd66e547d8bd03c6b1ad007345096663e78d10cd797d7eaa607d6f5cdcb3642f02b857e778b31f1adb85639e955517d9de60cce971584205058da9a03f585f22a036636152302070670ad33f17e49e91a0ec57c100a1ae1712e8a9b5be9bff95e9080e501b68fd3f0668aa390dced7d1d7ea2fa44cfb07dad44147530af3fe599a5b557576f9995de16717bcea6f081b2f3e9f2263d21fb00b4d5a6834ebc8e030d0e8e9a6afb248072baa999db521ef69b2a6f573fde62c58d8ee8adcf594f384ff322101d58d492d162e242a9be858e9e800d858b008a2c3394cced99791ea51e875497074229303826b29aea93196176b201ee74c2283e0b4b96636497cf67dffb9331beb703e12ae108dd5f26e0c183b0d827fa3c9f7cda07f67b46002d1049549dc246f999af3c1c33c56afcf51e6eeb0e10dbab206c375e9708f51a60cf0068f5030cea71d9b950d63bc4b4e0e8b3acb90edde8982b60c7a1a10db9e1e020c7eca8fda133a73bedae8082b25e4b1b84aadac2e5d7ec163522895e8076d619619b3486196b9a9f5e349b602c1248c3a6f5de98c2ae1c527c51753c306a7fa8da08e7e4e8175ff7e1d02f8a00c56482d7aec3cc1377a9b72b1bfb2bed40d230f8ac2b20a5ac70d9f8a7564b3333ac452ccc306faa873784e296f83e2710f618bf0b9ea6eab266cc7c014bc13d1907f69e1f91deaefc0a7875fc86c67aa0d6195666b80ebef386672dfc83bf3813ddc5fb710e438b45af89f5fdb055c0f0f42b316ff3b0f2267ab847ecdeb6b4def668c23de30b7d2c0f698b82ec14303e8f0b1da8368a29046eec030da8a657df13cac6266cd0a456c946a396381bd48b4e11e97c03faaa7b6cea84917b141eefca9f4b073114962d271e9aaf5bafb217868d776e8cdb28cf0e1c286401a0f3f87b0aa66347474bef07fd829f911b4707d8cf5346177dbfd30c0d22afc835d56927eec604fb36de2acf968b5681fa2a70f26bc994dc686877de9d07dbbd46cdb8fb4f317de89ed2fdbdaa4dcb08522e5634bd8fae79af70b72fb7138455bce1b1436dc6ba2bed7684a89c7aaeb728bdbae308007e521ba36b58bc7a27d299b557237b6184bd1a596ed7d3c060508f1e07354f13777e351fe21bdf3d52a86d48482db122b57a68c37e3257e9f76c1aacfb1a5d71862c291cdce016970d8bedac017501570d4b1d254a954f690dfec51815a4ba87a6d19e60a05c6cb35cab2fd0a1dc72d0cfeef2a022331c7818d7f1116f9e962238a071a0801d2e161be94760a3c53e593ef768203c1560c7cbe17e30fe56d1938c1fab04f6c2c87c316854e513c35964ae5a402e2ff33842af4c2081383660b9a47dd6c9623c510f5acc40b4b969de9c8b0a4a6d8ee82241ca0a8f34464f5dd4f88a078b585f8f6fc5e8f474ae857d9911c81a9b315ee71eb0b703a0cffbc2409901b6d940a8feaa40e37d4ed54c21204cf005dfa58c74734c0537ee0a7d1867d18c1d7fd1295d32b8799cf404f7316faa880389f1972f43bc5db5fa87bc0751d5c1a5706c81b8867fbb11821db9000e1047cb8125baadfeae57ca546a86776efb0d4ce500f160bbb5f4628714750614769064246fa62f165c149f59f7d2049ee42e9fd7ecc64de3f5ff559d4a3a53caa0bfcd31b5a15eb37bd24d882188e11079325c86fbb45f403fe78441759354a095dd805ce77c544ffd7dd362c97a95c0c1bf640b1ecd120fef290fc850b8bc1a75c5a860883c772e3b3d2a31f113f3f7bbc844e4cdb81553cd5b666a5d368aefe1939765494deb9ec2528608c5a80afa294fcc555030a156af701fe7a31345216ac4fe62cffb7997fab77a423a63ec1f0872a958fc248d64cae10b30bf83b0936449fa1632376e2be74917443c0f064c4f3cb4c686dd27a845a5228cdfa37322707b10843992e8969cda9e85cdcae17a464e021aca1708eafbcf15f4ee226e18924c2bd0235949fc626e0532c2e3d251477bf1823ee1b59fb415b4a7a0600a627840c1abfe1c665b410e067cf6e62dcc376873912f09fd894e21bcf16317efefe85ea56c038285771c102e32bf8c2ec3957b28dfe8483d0a2922d61ac1b8852ee76ae3002c8bcacd7ef22e83f6a26e0a786a3c92117d361a59fc73b066e00eb832f18e18ad62db3ee9162158afb01269e2eebf51299f7a8a3ab471e211797414ca6c49a501e5ea8e6ec3ac4d278e2aebdc11b4420a317389318b2428e3c63857d900c65426ebabd2baaf4071d6f7d26515d59a33f29ae3fdd3b994fc5579d085fe89bf97c01bd02f6a77a812fd1d89d55d67506e4d15273a5d6f193b6c7a3809fd425535cd2cbf92b84843882d43d285e268fff8712846f1260fda950a988f13049f386fcb15bd9243895544eb4620bea965c0101d2aac80e0f39c3de4851cdff702597803f517e7a6c26642cc94d18ba7cbb72e1671ae9ef2ac9b80030a425a87160f87b52fbdd2541a3d0c7692c9f68c5d30db6cefa9dd73c0f71efd0a942705f3c609992ed407048d287facc327cc6eab333a600963da6e7aadd54e355542128241ed89290c08a76976c627c8d760f2cd1d10a627aa723da4da444c10bb61204dd53621ef3c1bfeaa16e1a223b0c0861b8a8d91fa1294cc29f4ace06df1c88716fcd246eeab75505607ba0d706d5ae2938da694f2bd98f20226b0fdf78e3e27e0f66f82e07829bc0d36e07547e04547906a4925fa773ddbb6a575790d283a4e649b678971582d1764f6fb401662e42ac3020f756bd993157248cd73792b8a8cc1593fab3f89e7a684be7c51adc3f6ca5354bbef624e3806e29174fa3982b3bf1128d166451f23a045258f05e8a95b54cb6ceca799219d91b4a7374e3ef4fc007b97d6f785f05014e61aaeb6e242e98d4121e7db3b5cf52d839dc75ad5b54d998dca512cec3306b6a82673a27e209023412783512faa168fbce2be6724e04c1343179f2d5db4a24fa0922919d77eed5f09e2937cca76ea44b9cb29018b560b5bd493a54684ff39f7cefad6767f38bb0a120b6a56e3cfd6907653d780e1225838796f4b878aca43407023ef6b7f491397631804125316656e5fc9c828cd11d0f95cf62c0daa2609f591fc1c391f480cc28caa31053ae10aca651313995ff7803b63b5784361f6888fe44ceb3b5cac353755260b936a0e756fd49dea7f67b4f2efe64f16c5e4014edb5c7f4a4e636d421f47c745981f3836eea883831db2791895b1a36ecf22212be976f4fae429b659314cdb4f327b17ae1721314f7c706da92ee1f55b2dc22fb06f0de53042a5fed7cf38b3f313c23c11146f0dc24027eb2cd79f5dfb3558e2d129b977c0f600068ad2dd9ec8ab61de6613e04da09a2889f5c2d2735bb4279d7003cb191e0fda7d6d48c508ebfd8553752ad8fd8cc16f9a69ebfcd25d4f2d44162352443d8ad8f84a6d50500935772ded1a8c272fa3a254c25f5ff11903a0e2f35b151f39d86573b58b6d714ad258f6e51f4e78318126a54a1ec3feaf711b76daccd532d5d18f423f9e0fda204ab670c2f29f895422d7e8523cd8677caaf5816b74fd6fc51ec7885073fae6610c5fe5d12e01478904fa2ea5e357cb2d301628333b1a02fb1520a1df86ab7bcfdfe17542a56bb22fcacba0f59b8eefc56faef2489f5b54cd6279ce53a74db3601f005485223b3f42bf26c5d459a04e2088f932da004bbf2c549aa5ab9f48fe642086f465d4b027025a487e769c290c3efcced958546d737343c17d136994873c1cf1d4cee1eb03cede6a3df7ec9d25a31a751b707c9d28c5a7f9f38e36e695187003a0da83dbc16326bf61babf1588003995c25316b92da1ecd8cbba4634108d6c76434ae90e6ca6fcb207ec7bb5887c64b0d21111d54be68d5d05c16108d03a0f4837facabec1792af47d34a8b498f02060fc0a16986aae56a6f1b3e2d8acdce7e357fd8dbbe1a6e8c9e423df1463b867eb4c1032cdbe04065b03989bb6864a70fd0a99436ec58157f9dca85101ce428956a089e912d7b89db71e8a0127501a8f0d7a54b8c201fc4976627ac1afcd22798de85edbca2751971a9e0903c4014dd1a35d0a82c43b24de82f61363415f14bc5a6ff9c83317974c55a38c6ba64551d13c4994fb563203af385adbe916dee26dc1bc4323580a3a43a8b49d0408142278d4c90be0723c5a92a3aa7231251afa276149fd1868d74d6790659695cc24896cbd44cbb0dd5ef63c4c116d7b9dfe0a931a33817edabbdf1e6354dfa3cdf9d5c04811580837a69bf0bc0e6c61377710432b032c768f950fa891472f40cd9ef00d17edee515c6b4a6c688f2fe54331f22a2c45aeb10e7f3074a09a11c9d6024715ef26b302f38d5f3eb59cdfbf625a331951fb9bf4a763f2bb8cee3c8ef4ef245834726de3e72164b1baebc2bd585bbd52efdc3f20bc81c8d50af97851561f764a785b9ec5985a459956cc6ce8735941adbc95d276efaee82928fa64faa5eaedc0d09c4e9d3cea600a7c6008d3bafcc0f44bb8fa1c9f6365a63a125dc18b6318ca55b35ec30ae92ed3b3c99e717fb2c363eabdc5992603ea200038abc8e4d0ebbab9c3307a1a1e194a7491d55e95f5d6f2e754ae93a403ac7a67f2651edea76a887a687d4f02807a4c718ca1f998259c8ff771443375339395eaf7f9831c2a819969e6c0660460ee10f68303fb78675014145d93cf33f607adce21c3f39666c0f651a0a3d6405e1a21c9392ab418b4325495fd19589700d4b8ad4bf64042beb985e9868939487bfe034a1790fb39f2a836ad569bd76f45448b113cd5d2423a17daf21f8a17b60372177d5a04baf22bf0e9e4172272a110cd27e45135f1925aaf0974994321d5caf44de1d025352921b3093bb34d7868a3de672ec95be3da537a8c95dde2138c459c6ae460d1ea2cd178fe21ad542ef03cce6675c6c642086de559632815ccf89eee7d75667cdfca3d996efc4e7d06b5bb953dfe96f499891d6a709ceeb4a6805cf1f9e2f259ecb3d8beacd7284462a8dc3f529168dbda945d849a40044a714d356f2ea1c569bbfee51fbe37c117c3d030f70f29ae47517f1c6350852b5691447b9f19412ad48327d821e7320ace4e4122a91fdf4a45891aa08199c60dfe4e5d09efc386cbf82dbcf91d79269446c6d5a80acf601bd8f597568236ad6d6e460c478cac0b5d55366cb63e6b73cde6c92b8d0de7a32f04957e73a88b1e159d6030c417813b6629ca9ba6abd6d2d4ce6446edfa793cf31ae979c45ab3a00287378d052eb30e60d7cd7657330da6cace7aaff3f5aae6eb8a99a130bee23b15cee57a5890b6ebfccec65e2715fdb4179b7e9f246eb3b475326d7edc4667d582db110a2cc523dc9a913f23c5eb462875f2f2eb71109e80464cdb1e6813aed94efcd345a1cb9b5a313908696674f359c0ed77d2590d144044c51799a6aa6baea1325cc1288217b0d25d5555198e477974393b0b707a5a096fcf441143825e82d5902795241922e50bd75d7dc044fde8ff05ba753ae971cc72898e4dfeb0b2a98b66b18b657c386df51aff2310d4d2c8046745a613c9099aea81bc1b6397395f7ec2e1a42337c4fc9c61954a8f6741e1dc178a4f496696c8f7fedc6900b25a0994131a917d527a30a9873b33dca3388a99fb354e42fb843d6696bb23ba11e7400f215aae593e5a8071fb22819dbb86b5b77b81e20909b4f427554f0b0bbf302ec6236bf3c099059e163f8875c971ac6393fc490c3e65529c1a7006501ed237dca0b2865b856001dc49c761d3426534441c1b7c2cd0663350fdace3f927bcf12e0bf941fbeba50b2b9249ae68f29c1eda4f39c5f33e6174c372eb037b379eafac0cf56f8693aa1035abd790d19d495a023f13fee5c877619bb1d831adcf294336192c85ea7fb3ce66d808945bee5bc4a39e84e18a62c8d18867c1a940b54261f53fd6b72b208ff2a51a47f065053c461b9d59339b321835ded3e0d64628ed919e41d3fcee1b5b9337ff8061b8d0d81c979a78e2ba654b34c25455501755739db9326ec98bcd2fa64f384f2dc3f1b1e7b7bea2d301b18368261f79cd951fce4bfe6a4f9fc823cab6d64407d1b2d6ee6576d313c18f9dc2b229b729bd6e1a4f7ce60b83f551068a9dce6c939b31c4583728705ae48d1101bcae34e9f4a361b31e43caeb04837996db9c250bdeceb6bf1e56b0c85291806b275d3be345b69e8ba47d053afe1d5bb2ebe4fb253385cf5058d752e31fe94c75b9e8b9a8e838f7703fee916758cfdcd61769d3a651c9b5734a7cbb2d62dc0af04f94382eb5e10af30c68f894349a036b9898460c8879c00ca1c2e4850ca80e17e72a4f36ef2624840bef0a4887771d234543ff8e5312468fa7e23fa0c65aac247f6dc2adbee7b55056a42ecd33e3443c171f1e6bc3750b9770a7f186acb4c6db726cda5d7bef989f8cc0c3418fc7c4e5292e326295746a2343eb715f98083600562d9796ac8c274e090a12208fed6f4c02e4683e73e6b77a5b967dd1fb8799fc0c8acddec9738ebdb0aeca8874b055bb44d390827ffaad85042e08e87455287f33f382f39cb142cebbebbd6210001de7a6ff6f259bcb80c9557aa0e93ee63b2fb3daee8544e22c517491853785c062b3492f87880721f60a1db19331a333a8d372bccc03e7a7cedaab2b5e80e810df31768480a1eb02d20f6af22a676647e5a6fafe05b61f55d784d5dc0df2407be7392969c5c9e096825186190d558fb4c3dbd84a148ad6d4de7d3baf9d4f581fd9a909897506074d5fe6f6db0b7ef2e5e4ca19666fcbb5762a4a38ff919acd97856a27dd0aace2e072002f80e2f1e2d363cbc40b5a5685248330502deb358cca742a7c616559b345b3cacbe30b6dcb100fc940f70cd2e5cc75728779ef43bdf480beecacc17e0c01a38c7dc785dbe4dd794449da9824a8ad82dfa460185f3490cb6cf1d0a8aba29fb9441e9f8de177a7c155e453b96bef7432385a703d9a052113fb58d1fc3766bee00a90921c1d00b5734208eaf05e466d3d8c73477499d26381f721511825fa1db215c5ce72315a176de104f99b8c0b056ee70231875355b4f8652cde8ebcb45249f8b663ddc58f828a08016dcfbaed9b2f0ab23645232b1d11da2715a2abf319fb3ed4b098f7c133c7127ab34adf747793a9d047775e943259babea918f3a8a3c5c7815ff8b4c07a98c91f3900082adb2771730e9a02b53aeb704ecdc05043a82655f844338f598c1c9d3ff74fde39b414d7232a22a4e2d27712b1f90c6535f824a501e7fb3ae2cfde8001b6b509ebe352f66b00ce477add12c70d4c2e679b7c2dc37d76f3642ea0cffcef41e70282e6ba977549a15a9a337d46d55eb767cf054f533330182d52992a4f2d6ea0fab6e5ec216283114e1c66fbfee0bac88d68dee3956fe94244498bd3206e60109fa80894ab4af835f2794b2eac743116c6db98015bf8844c15401142881a56e79faafa6b0b5f4ec6b1c1a5a2cfa0155e77e0c26e5247d38dac5966f813f9c05ba4266678f5c6a934e7e4cdc0d50dc6daf6c169e87c1a6f90b77ad96ab73d49861bd4d5292170572c44e56a931806fb25d62da83dc50f33338f7561ec98ff83f588545fa2b0bbc6c2cd0b4e32a36459e67b74043d07a72cd52e5afd5b6062dbd1d55111985d8942e0d567b0ab6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cbcfea95816eedbf163e23f7de09d842"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
