<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Pàgina encriptada</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Pàgina encriptada</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Contrasenya"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Recorda'm
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DESENCRIPTEU" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Contrasenya incorrecta",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c0f0116079a378b30d47370caf631e3678f76ef02d361033f74326636d48376051929aa54aafdf3cab52f6d6b2b1d8c855880d634fda015cef936618b96d8225f7ccd25e7be7f4c1cdfe9ccac4388ca59591a0c92c6e2f52b7f1c38bf70638cef458bc3654ddfde672e7fd6b0e6136612d3a69a571ea20f7f4a9fc49c77d25006b7fbe414971d41566f0fd8e58cd5f1b970945f114aa37650be3b32831779723865527e7b1a7b073edae2edc99017552679d2e43c724d302047e83734e7e6c809e9d92415d62543c369a55b5d97def05e8097b92420b0cb64b65015cf8279d5d6b9f087bafa34ce4c4f180f45724d7260ec5864cde6f5ead79ff6f69b22dc6006e8a8b571af66103971f9a51eb9b431ee39f194c1b230b2baf2f2d1e53a4074853d5afd272d0dcd22fb8f58bf02d31fa2c571b7257b1e418fbd64be4a1769b251040fcdedfdbdb465f8f5bb98ddc53bce233283030b74bcfba47456880d27bdfa689b846659fd40099cec2b5a37fec57341a2aea09d7827f77d611dde0ac743e84a0e5112fbbb668bbcb9da3a9c8ecdeddec82f94265467d7ac2a748fd006e84e82625b439d57b202998604949115d2edddcb190a84d948ea59e63afc4ff536dca3206a7fa9d3581389ee40884b2e20f5d10067bae3b352b95646a647e087a030712f80a4c8a232d23d8dc33d1d0e5f7ed3806b9abe139f2a1f808da8994e98dcb288eac91af68df092ca05a1f84f655fda73d8532411cca63e9428e7b5bd0f43fb3d3576810f820db42c1473c6df92ef54a774f29038a7ea565793a90929350106baad7ad17977d987dce95e25ab717592c839d628fc3afe4cc86367f6b5321dd6f1dc6cf05597c4ecdbc22af5e454d3d0b763fa468cfcc06e132791657e3be1a0f5c4e394c7cacd5975a099184af426a7694ead815190d4ae2b5eddeee93939a20ea22ba34c5f6716bb13e9d6e8b28329d2ddde5ddb0e1e2038e8baff5bd627a2eb4b10d085c883ae2fcd17ead5c4a6d4cb5d966e7e173cb7c3e1e6dd2fc429ed0f1d1e14ddbbcf328e9a5c8f172b8edc451f569ece3fc0ced74346b88229ba93febdd5e5baa3ee0fb6dd1640af982f0aad67a4853b47dc6b829b2e66ef8d54c25c0b50ee2132e5a6b79cb3ca590280261222fca7da6e6860590d4a90e860e00aa6014c03dff6d0faedce33eb748a30f38167a540bc89d000089cf3695a1ccc92c4b4ff9422ede8b7071056775caf033ba1439e46de4d4ccc5416d72dac5a98545d7784170e30a299bcfd255af4ef0d165ccddbc09eea6996a993f07a54d0467e3967cfbbef9da48bd363b53e837c2ddd441f5c30b3b8de35901071e45bcf4bce407dc6dfe327264861baab3ab1c4deb963dc143531b764a715477fe89c25bf1a4129d9c57cb8fdd227eba7f2be6eea72d8b822210b58fd8f44e7906a620a4d968095e2c840cc85f1d4e41d6e47c74128420e01299ad498c9ec51de32dfaf0811d37bbc6d5bad92c2f4890a4fbc4debe9698faf901d1cf3a1547dfce648137002fe4df800687b2d8472e3d02bd7f44b258154ff39c1bb0664e27a5992ca3eb384870bfc4fd9c16cc61b163b7650ae7b050f77b93604ac687328e657d3efc91fbd5bf9700cb10d95002e04383415817d5c2b87b911d61a4811dfc822de736f9b16cff02465e7583c102f03cfb7b238c0648a6a3ecb082ab0d6be30f8922140d7f50a50180823c93821cceec22bbd9b16e1a17d3e2f74e5cd92973ace721b60bbd64e537acfd0f0763c66ed767fe422a0b0b5db81c14e2359de748c8a15d345f3e5c958de27653a38fc743e01113ca05f40e636efc059a8f6359ada90850080a8fe3a19a4e054fa21ef09200dbca4a8023d8e04d6e323a2a2e37e5bedd9af1ce89ae97a4797c3af72476734b0722605a82ee4355d0d27d684fe2325361514d63f40edcd21a174c00d79cc73dcbf239ea1aee3e65c2fcfee361d3cc9b27cade0012da4f711975c1707122f1a70b12e1770a526bcc57d72e9c27ae6e0f4568074e2ff16a535e1cbc17a53f5d3bd0d54152c9a200ae14d9760886b62ddba6150c68aecc5b416271c95f27d60a299a87a0e52b3731c93cb94a183f29e807836b2c1326632168dfb7774c93cb992f5a2343f494aaa84c43c71a1042a3313207c5f7369bd1ddfc8534bf84b16097767ef214898ba2d9c16f3153a69af43c11fdc038b70fc95f34dd5c88362816eac5404e0aa5eadec465a0a32c5897671a22e0185acb1fbd331444b010a323a9ebec0239ed813a2edc41d5b63249db39303cc3adc1ffb2206e6eac41a9ad48bf4089e4f842ebfb1ab64f568fe820dfa2ade73cc37cce2050e33dacc91e5395b824c36e5e416a0f16a71b6affce2abf69bf9a7549001a5c06aabe581799714fd42bff1b14ca6da0d5ad7a370c0ea3d4eb6162a2acaa83bda1e498764b9921d0384261391b9c6129ad5984a69a6a71d80a6b4e650b0ef3b2030ba5aae9ea73da6627b5f1d624bbae661a17dfabf6663bf99be61bd16901f93a41762e2baff95d7b584e8f727d2024f0654e7c9a28c86f9790398ae7eecf3cce3934d917190b602617a85559db8c76378d0d07202c4121188ec423c43294def59dd61965f8278acb323b49635ea5fab747a01f278d5fca3e762ddb0a02ac18d01bd68d9e9f59f692d29fcf3eec8e890fd2933a0a6e8c7d1eea23baa045427a85d299feec76453f11c5c30ac97307dd183990a64b4400bbf247a10590b38c9fb648e22594c088c30977e0265bd8656469cb62444d112396cff8ad5a43161d7b9ca3e0bffad83b796602d11c47a5a05d7c3d7ecd574ae2e1d947f5d60c5f9c42a5a0e46e56f6577960cf76cda4a63aaa136a5c94d6a5ec5d73fcc39f335ed28a50fbe429987117a90c9543df11d61a21c3b73cafce94cd130bf489f1197095018a6fcefffc295bdf81e55473af3c645e496754eb4c2e34c1ddc8c1b6d9884c4972a521038732e18333026576cf4da5bd4ceb039a38e74d63cd345f85dc2c32e08f56b24b4b485f4516f088c586cdfa8666981c936d125db47bc89d5a739e0a0071c21d415fea528f42557f52c0bf2927c88e5cc4efbb359409f2f15935a87a99a634e73907e5548e98f17e4ec4a61c4e74c66334348d56f3b908e44ca3221f2059354fdfc431b79d2017e77d9ea3eb240b3b20033c212ed66c7386732ba77b04a75e6bd35e7538703ce445baa414b48e0ff19f9b922fe47849aa5f5c0d918e6bb5ff8ea69f1a643e3e4432db8e3a981576c9514e1396b71cd25d754ebeca672b065842497738d01bb1cb7b7494d9bf4f852db9e8fac6ac0f67b6f9891ff05db737820e0ebf1dbcf58a45dca00e5980319989aa87ef516174ee817408b570c14ffac9216ffe4abfceaeb2cb0c94c1d306cd9dcd952e869ba66e6edfc55468f3c62a70f09e4277a902ee5a5768319e6e8b9ab3c53c1ee1bfdd13fd0ff379879412891ea2d5099637ed3b07544c28d8bbe3b2f225b7015b3f33da5f7839ae20e1638cb299d5af8b910dea0bc1e6ff7fe33dc0034ca1f3cb49f67965420077325c4483e34a6d39bf9ded091b4390c32c8d6be92029bb0b6a7446a3885af8879877ef9037ace2538d319ba6979ed0dbad98413b7299ff0ffabce673eca8aea317d9c3a51527ed50bcd3486396edc71f9e044a844ac1c3b80d75a21a10fc66b7885ef5ce9be589fb672a286e7be87625798d615048691b4ba010ffdc9ceba5187ae5d8215970c824515f0df6b25a4ddb1aa4b66b1106c8ea5befebfe78c4fc0c4d19310528ada5bb0746bb7f7f39ca043d450e927b8d5f1b387b1aa9a47d44d1bf8a6828e62531113d814b6f61d1808a4f3d166e8c1341e203a3f5139ae85e85b2e207719c138095c538435e104bf738855270c3f6e87e09de33ba2ecf431c8ef0bd1bd49fec92c841dd2d39757e98c53fefc410354479e9d2836f85663f84bc008f03b04dab902f533c1ae54df12a4c66f108e5682c0e61dbba1f9a74e56980760728de15e00b58c42fa2fb051558e223c8a9788deabb67fbacfd962b05d76f3cc8dc3551b7bb12c9778fe76c702743d09c324e6d1ce594cf7776bece6e554797db87558cb85ab9a0dce678e05c2339ef7e71d9b71c160355a00b7f98c6656ae5815a57eb485d6763b46a488c291a4897f2c45cea96fb769fcb58a3ba9cbc9b2e1a9345556a95c09f3955c3ce4669e45634effff05c12923373c4489260737702d470e2ed58da79c09f7da52b60eeba44b1e30d8023885fdb3fb0ac9f689d11b1340c5b37b51aa626cdd59ed1f7d20747400d68d578dafa48a3d4a6f164acfeb21162a493729d65492dded898227dc56c4b55e6ace23558cb862c897a99d70f3f29685231f82169f4006e123d424e77f7c9ca65c18fdba79086adeeb7efcd3bb6a30fbb5ce0e31322f9ca0b80df91f848280eeacae3ba50ac93f66d64d677f66fd1f72b4b536bfb6252e040b457e86b2cc1d1849e7d8d67ef6a128a2d84edb465b32f0d8599719e315b027ad11251e111adbdc2eaf6e03e3b65a336842b1bf0f1c4dc2919c0d1c02a851aa05d4a9c509211384212ce5b566cefa694e2e167a0c42ccd123a8290b3dea3a9bebf8fd88506204be11bfd8412eeba564489629a3da628ff366700bc06f77cbfb2f43db515c258204f67810bd8a0b0909340afcf696658b81c2ec19449e5f8d0602f264c1fb9dafe1ea36be8b1ca9986157b2235aff5144f587bd560732fe9119b3c52d934958d2a35e9d0a0e499d2cb63e27dcfd1c8c514711576c57d98a2ba713592097c8704ca48a0d74d6d5c5303b93ccb99a854093533cb2bec63255bba877cbf75540f32c08ae47d5c45bf4b5584d19278fa6a6a736c9dc9575bce9586d2f9bec1b43fedc78be7196dbe97b9d4c86b51a6b35a2421f1d9eb41c50ec55e77ecb6143ae5177cc87ff6f74d007f1ac85040567c432d9c60e164cf1010cf41208b8ca39f8851bf43ca47b9b44f84a3f93e22bda37691f729384db5d4e64310e6ce891eefd9d7516f630021fc10d34ea6b55cc2020467f34e4e35b666af4215c7454acdaa808b62fa1653facaab2f52d46ff18c9d21d5f4b6c8305559070f6712dd35130b9b0ca50f523dd9a656145c3aeda1696f87878e228ea11e7ef5dfd8575e07a29305d3e3efd6a954b86615803fa81f4e5754a78e464006e17fe8f9dedcdd0c64fd0ffaf7f12b578127465c97e688c61ebf58a6fdc3fd426c6baab55ca49141222bc33d5650a8e3903b017ceb386c75b8b57f53f3f5c193104e8e688302ecacb2682e84b69ea13377cb87f38e476396cb3d1d56b58f8fec48e71e186d4dfbe8423def69fa4a5ad6f7c27e2018413c64c1258232f1186e6e79b2c55baf3abf3e36359afb152f674f2c603665e66738cf29961fa473ed8bc89bba0b1d3e81e0a8f00e3df031c55234b89272d772d6360516dafeb161618a82d7a520de9dfc9e5a9bff8a0ea3f16cc28e6dd5c6652229a4a5650ade4cd9cd15bf05be0ddada2ce2965e727be184bdf876a7767eb79bd88e3b3502e708c067e6bff97fe060eac815d4935f9f20b0b09be92a9afa349b15b52ff4313d23ab4c9e64a01fed87308dc7851b6a5b3ee85d92930e5dc6e1dcd04fc33136126d2e3e1f7e87fed4f535d45d585e1c8d27c98257fcef1c9be039d459d98911d8485d99acd04f176d32a6b43f3fca38e14aca4964a417a53db6b8511b386a1588c09b95e1c4400884c52ff21f13627a907caed9a40bbf27cd4dbb76ac98ac1cf8dabe1e2c9d4021af541cd0d589373e7f17980ddc298fc62c8958d95847c64ecbe31a49d918d05f3678f77299db6f4d4e82b0f09e819b45e92c78bbed0d3b98d5f8c512a0dd143667c9073179c1ba6daad3d036714598f95a98e70e6917660ee607a92ed9d6006cffe776d4d284c688f6d0838cc88342cd87ca27f24a749533c1b44a552943705d88858a6fbf403658aafba76093bdddfe7ebbb66d43e469ba9335d232b6fbdb441d38973acfa129caad72581d006707ed1fd9d23d1689c512a8f21b3b162dc5ac4f756968e39a5556ffb1116d136d22ce5b183ed3091bc0963bfaa54025f0479b8a30314b2d77953c98e1bbfaeb6da2a5e916b70799982a07874e36feb9d6fdf1ccd6b8edb864a8a5ce17db894ae20cf3673049bc68aec7aa6dbaa375f81ba1643ca05a8b4548993992a1116a4ad2912c1b895a4995ed3debcaca37bdb46460785d5e783332e27e0a1058622ef1e4c378b0eebcce28e0b1fe393a1cb341d1fb75d2c583dea8d6601a1f1cf10f085d2ca01901cb12f3eca41211174eeec412bf021ac68a09ed12980bb45e17a51aa1a939d374a96f73be0611e1d1c90fb0987393a0f6006939965e823f1fa91cbffd1d28aac0637c0783a31e48e7105fb3dc8c5091f9e6feb75833e503572d851e7f29ee3acfa8cd47afb59bf558a4bd705579d1da78600f3d75cf06453d69f00795aa4bdf88440b4a34ee34b8d746303454fa533433857bc1f07bccdbe965e1927d2829d2cd0e3cd198564511f8ed38b81e37849e28ba302a35277f25247addebb7da1c46ebfc584c4c6246610470d92305417d58adc18cbb0d48882dcb1e4d3daed2f031a446013b290438df08bc76a546f263ecbf517b85821b234e3ecfe46f0bf96f9fc9dcaa25616cd92702fb59a26458be62633f3ee1aaebdd2940401866295be945f6e61cb251ec3dfe7ea392f31b9a45b97b17b9c773c2fde876d53826a5cc2b8b8ab45f10ba453e0927eb85ab68bd32e33df6bd9d0ee7d9044b3fde754711e1c09bb94c363ce3b85b1d8783541363b2c4c2943c35e9f813a90a1db33c046ae68238502c821056b68f1cf7c5e489a942ac5a450080481bd1fc50eda7218ceed3d856d15b0ed34da58273a8a8e87d0ed6d5b254396dd07287ae55153537d6dacdb7855a37db8a4f1812105d6cd0754f781c063e7e6e3b1e8a5640c350bd061f34fea33a1e01a632b004878eba5577dee7c2613ebc58acd8db09ba035faadce8b6e706e03015ba85f253fd0656cfa0d2d29d79b072a488bef612744426c8503e1c718c004ac41435d7f16bf7cbe9a55e1a66f8589c56da76861a6367b6f8f387fdf0c3bae8d9708c7cc00ccf3285c28f443f91019497694135d7582afa05e822ac13fbaa43097bddaae2897f76b9bcab91e0e8538ecb3dd2ada801ae16b78f11e59a249609e31b70bb684184a40149c656df8adffa3604e5e68776111bfe5f5b2abefe0686f18010a7c1766888fc4675bc815eb44eb36835fd12c75608ee58574567ba6cc3a1a324352e80174a5aeb28614906e5ecf40bf5abd8c1fc72236070aebfd74083c31314003850fcc32745dadd368b7bb8dac2507b743691176f1edf95791ac093969a4687c4d35cd997f3c59b60504c0b2af09fc09ebfa1522cd9e6b16df22cb57186ec07546b6222d6383a4c84d2f1356ee0c6808f16bc052fca4cc8ab816a01e0fdf12c6ee18002a12b69c7be50017e0aacfd4f948ea4a7243e48142ad84bbc41d9ced9cab417f7020b58963be634c176dc84745fc331048575d3a65e16244814db131e8976112bf79caf4b774f38c8b8ff4d39d6e8f0531a69073f02d2108e66f532a1f5ec19d610f4f17a875dae8ca92d44aa174802f759363d03cd2941317aaeb3590226002360a4fff3acd0466b9242f0aee4c28963b9b9e96d15545d38abea0a199290e9b63fe8ba369b18b1011b1f2dce6134bb5c85124d07cf003c936073dfea2133181c44057f33369472606f614266f295267fee130cfa73a9684e2de9160edda2bf35c59c4cc53133bea9b72b3814bef9902db5fea83fb0a72e3750a8eed4dc271f6f35e65180cf2019402233d39600a6757381115f5b3329ff3f8a9c08ea6ab73c2cb9d3df539c2d4074d2856a6afc6dc7ddcd6acc89fb74e0ce3544ed29e96a7b8d5002a96481e9ad3a8b6d9b12be95a4c5180a43b7f17572f16d3ad60192b1fb7743697de1e6b1ed6962cf57ea2d253033c70f002731ad0690cc4d1c56af35dc8af13e1fc9adf81dc34c489d70721bccd17087cb9a6cee52747b1adab5605013cddbe37adf3a0e9f7c3b18402125f5d2a40a59b25abbae53ddc0e37bb20b0d577987e93a77f440ec684b66852b0c420de7cd80e0d35d128339bb1e3570d29582070054bf9db6027b98c2a1e00f3c4ca43af9aa95777ca9a70dc994057d18c85251e3aa465ae16ba8de7ac9f7e5bc30762954e3e860133a6816cfbf77a173f217f6e2f077488ebaeb41f96d2cdd07af1b09311a471e8e32b3847acdea5147953d8d48d975875defaf5f705bdb7a2eedd7d03ac1c1a39049afae2c81859a2de783a95a19f989f87cecbea6f220f17466b9dea0a9931b7da0f44988476c6c59e9ff304f3cbe09ede2c40c775f92591af8a62f435cdd44c9cae67e4063e2cab54cc16f818fddb135edc025ecf4f7652e43b9ed370b3d33168e4e16d17720ba3492ff1fb23c7e13ac0678b59c4ba4784fef33f92961b352fcde9fc31443d8a63f61d0b231f9b9cd0e7945c5ba5d13eb9bc3c03861d025f16a3bd7753cf61d316f9b85ba32615c2ea37faafe271aaf7eed174d3fad65b99d3461470aea48af5c5ffe750ed0124c69f2d6d287c4579794ba50ac5a92e5534d47c9964398b16e421f6f2ae58cc70ca1c101c6ec057fc445d2b7626479b6a0afa0b95292a3459850a1fb249ace461b6a8396f965691b7367e6c0fa981ef2091cda32f15873dfe6e0d89f66efc55e61de12677fa4cf42d1d823c98c146274d9ae3ae689d3f930e6ca2ef4081f3c79a9a53fcffe318d35ac5365b4ccbf2f19c71dd7c51d52452056cb4dd416bf91a671c38e9b4516e3a2141e4d60bb65c065404737d467c7030d568346e7e584da80188275b8c98226986c85b16e74a7fe1bbaea143afbb3affd1dca8b9d97882e249d263f6a93c39c4e7f75494cac3227efb85381e69ce18ce27db26ace4fe89c44e60fa84b9df94e7b61fdecdddc97e0095d7e2359be7d50d9021a2944c04d793c01e38b11f9b2798826e7ffba34c345e18843928fff39bbe1a60f2eeaf91aecedaea6a4c2f66b380203df5e91266396e88b2376b2c097bc78bf325547daee50377b5e0dad6bf8aa2b5e3fe5477967c35af468c54f4f495c62908f5a06b97915bfd7ff59a8797b85c869d79aef629d352b751fa8de557b3149a20505f8c2a235461df5401fa1096733a87af493ac52a9f8b570b756d6b97c4039c9d62a88094f35dd39cac476631f132a420a412512903a5cb40a701cff4c89050d335e4e43c1658c7859ac4360c3b4caa483bad9528251567aeb1a311fd4ee59e739d44f7003c760b0bd0c168b8c65f6a472ef4c838311280ffc7aa7f062234b81ffc55f33c9d95fdfcc49e4157c0460e23e073fa142751b1b33960e98018abef1951cbe7260bee4fa9bcdff5f047246914f5d728595d2fd86fd44fa21cf216780fae6dee887010f9d4272edc1b5bd13e1acd44aa1235c9a884885c836c7757880b41bd7ae7f8e2dbf3544becb93545c979fce388f5a12729c64fe01b02ad3c6b31b1112fb855a88e9d1fb15312b639ace9e81b1176ef4199fbea615574f9c179d8b38ba69ac9f97a483408e3ae9730f97567add7472186ac7fc40113103b734b45aad7ac1bbe4137d1b80baa796f71a3cffb39479a8bc0b2a93035b45aefc1edb476f82cab00b634f0108ad5a51eef81042ae4819b4e32ee90eb127b9e000ca19b117b99f8e033a616170c19e2732febf4ccb387c2e78e0c07cdcf924cb335f08177f76786ca96fb0fb395b0da58dd39da8de8db1a2b2e1bd6163796c66121580b3c346edb35f8dd6c108965ff00ee90a1ce94b0e0dd22f45d443ae944204d39ca36fd53c9c444e0b7e24cff5c758a0827913e8532f66a33cbc9c3a4e395d0ded9c094e8595d978e599f0cc6f7ae52fcc0dab277a29bf5f217451c0dd5470ae48d3b9863ee296ccc3b6570c8331d8e89a85035aa47eb23873ef248dcb9c4d41ed7015c513d280b7ad12e6fa7662c9b9efce147c4ea3f6e7cf0f69a04f453db812c0a6daa64b75c1d8ad40498a56bd8b2791baf9234c2580ce1f89a424fa817a4fba41116971fd42ee0274029dd229222f687d04c79ad0a47698c5616fbda249783a94aef86a50926944961bc5c3d65a81cff4981ad5a58605db21c46087025e93b2524eb7accb699352e6d81b7001b1c0cf51ceaeb1e62e0c2a0f0b4880c4c6e545a219a05ca2a161c2c24c2d4d13ecf6abb64464bf071dbe539d16e1a323ab5d87c7fda3291f218b236d0fd99344c659ad948a67b3982dfd81b833868aba445ad27d4245dd1c0269cb900d16bb62e2af61fbd16b877c5018218cd68239a5a0cff6b85696292d215a211a185e7c3ab706f27f9a8a242e949c5ab1c290b03801da8974650d4717f79029807286431af34699996eb9f4443e007252a72179049ed3a12c610bed98ddd8415366d1096ccf20808156dc527fcc795ed444683d0a38f21f81e831dc9b613535bf5da59d1b5862daee3aa23477663c2ae7f8a05b6fb48d1d6b477f1a6bb26bc5d438835d6713eeb7b8c6a945b2f164d957c653fa74ef91fef4e733550c1746ea94d57b35e8bf5810979acd2216b68eedd31d32ac96bc8e42812c7631af2115eb76c160b2efbd0dc047ee1bf34e737fb9acd44cc32fd8c3c35974938dd3d683bcdfbf7a3ce8a8fe838857bd0a0692e1d0b4816f9e1e1c8585f26c6594b1a31e97a4b07e4af10525a9b426bc170b4fb2372c8b4ceafadfe0d8be05173a23bf8ac1fa16c90d74f7a4039979e6d21f43fdfe6753ab461a53727c27d3522c8912281bdabdbac84673068f56d23787ca3d539485aa88a6871e63f7cb1e9808ee77687a6becff328279b6446cbdbd7b454a40cd0997caadd8b59bf5f8391e786b1dc4395b0dca6fa33860f611d8e94dead1df5dd62822c16e9699ba35ce11462734dcef3160abbaf6c73cde5b64b4c5af01c9e7569757b92c6cfc23dd1954a019eaa0e54569a79c672eccefc8b74a5183b53e4850fbfecb94680b2d947ae19532d1b240d556f933d5975cb1a2cd43228fc10be901ea0512e2bbbf87177a562454f34abaed2f68e48db165734a1474c1f9ecd70f068f3c8901384a9aba939bb44712e46920e68163d879ba2d73260136b3cfd8e9eb8cdd054938b459ef7202a0cf26eedd071bb11c156966ea46b5225315161ff906240b66f069726c09e6c154bf186a3cf1d4761fdd02aa5b2d7438752873b8c13cbd378dda6d48e8d71b9651cd07c6f2244c3b2fad439e4f079c068fad7b44ed43ad5b34428bbdc2f4020b5f9b011caf63b8237f5f66f8931eb32122e72fe118bb8d4597302ec6ef02f6e3ae4cb7c6678cfaa156cbe613d9275949201a211760d85153cd073faac2a4ee2d8ef9b674d11e6fa9b7c748b8e6135f365577971061b0ce4d9633ec15a37e816cb6cfcd95670ef71f0ac575fb7b2f7020e047a75a3334803bf45ba2ffbc0fb7a71022b3f4fc478a7ef965925f00de66e35901ecd24025961e0b34fb16f7e1927561c8ff3472d7c6fa3169397b2ffd21b3ad44a1e6ad4bfc5328e76640c11844bc6d424f54db12f24082c01d266cb0218ba545da24851c1b178ea6d8f9b60d822283caa3a79460a1996f850befd5c2c0acd2bc2fb4d63d0dc219e0df9d3bbb45e8a90d13d2d4f58a52e5382a4f81bb22947aabca4d557b4e69084fecf351d8b7ca3f9733f66a8001b54a1ad77f9d8e881cee7b2fa7a3854e2e6d7aee3bba430681df04a62ff952cb7372f56d6ab345a5dfe22aad8fe5ed498d9d64a9d27f66274c387a02c8d6b3bee70ba1bd2c84ffcedf3619518f99d9056f5adb6f7e02e5717964b774ffc643ddc5eeb8d5d00bf9467f97835fabf17422273d3b4851c24dec141563aba18638defd267d9b8583698ec1ae3f6e40f1efa83ff13e186a03a74e85140da18a82b7b7a7a7aeb912c34f44b8ddc06a01200ff676963a48932e309a76396fb233b31d2ee856efda45dcbaea7e6fedffaf5789f5443e8d241edb81e8a464ad8080e8adb3f2c85738adc26490b6e55236096e0878c71b95e956b39cab125523b6a38989e1839ed524dc6f9501040b1c8d0523dc7c340bc7f8b9fb33ec29717ca2da85b820c8ab03b532e13b2dc483a461946325bedcdcfe476d600d84650c732f46e991b1a9dc78b315de12e5ecd04888e83d9fb7a4fbec11cc6104fac5409bf6dcdab5bf20842a2ca2e4910adcb5376c81947e64e247f1da27f93d2637cf3faeeb09b04a64f9f5503171c288933fa54e1a33cb89eb1f9baa844f3b64424426fbb6b67f08599dba564b5e27a8162b4d773e34d8caac885d3214edb4b5725e5d18abedfd9d50cc8e4d9a9e43e6e25bfa5db588fde25ffe17227d036bfe52ab3405f7c688179283db4d611c964c29a7cf129b8ef4141538232b40a330a7078d2fc5dc8b4a996724d3365455ec0e416094405eaceebd9c5469ad32a775c035bff7dbbe9e4be51ae130c1d6af849bc0dac598b3197fa81e564efe9a55fda5fc26ccdff3575d24a60a162609e337a475248d3f8ebebefa1c0779fbf6c8993d7ec75574288bb55ef6058ed20b84fa17e0c7daaa4a3028234c6e7f04f035c092fc97d3da4f27e97a4a45d48e6385364dafd585c119007b3707c515b764d78f13b779bc50e9c329031bc2d9221cd92eef94ed789c51a00cb3d921b002f0efa44b776e9e84d881191d52466173fcc92ba9c8ad443f55e73dbc1d7bb11ecdfd25738c2f5de7381579d7f77923ebcc18e64c6449bb541757a287f812cb26ddde83660063695b5d9d95bbcda4713480b2b3bc2d2a16b407c2f08daed7ec4346e1a8a79777e90acc22fbdf1b111f4a849ae2973de2b5c040a23ea84385af11b7b47b19a839ba25dd4018ec561c17d778c6b4426610296d9be126d64b368084e4a2f7fca2367e58fd4849746dd8efcae1f93532de6d5284c651a02f9190c48e5aaee4a1ef8fd677fd11edae2d19ed230b5f6e15b097f2903c161066a966b7f93a94994e8fb5859838aeda9c4df66583d9306dc2c5ad3d421728ff137f6ca2508b3b227f761a20e5fd7a5e474c4564e6db48481c9ff695c76cd31bc9ba6faf1aea3655ddb767eccca6f84497eaffe3da9ff368a955e58e0b28c5990e6a8c7daad47ee65eebc1df00b97b9d290429e64f8baa010adc374a90d604050037d4b4ca78fd9a7702cd5c073c7d370fb57d1849ef6154ad312962554e5e42cf97a3647cade92174e85c46c25362d87c5e5f38b87d6363a3d450f0a11e92b29b8eb1dfb6d8185be030eebebfb1d7877aff226e3a66836b0a8383679d32262d47fd9e2f0f1b918a4ec4f1a4eaa436362863b93e6f2ac92d3c8efa9d38e214300521dee421e2ebede5f3d89e994c3b2e66aecda3b4ab1e7067e1bc8a96b4b74aca8207fdbdac1dd30279e4af24f871b934bebf4429593033d0868a42a4c32fd3dcaa052b5259f2ca5f23e6fb1818818eef675892e74ed671819d1053f159aba1affc0c6713c623755530f8ff4108ff78a6e3e5291fe2bdd576fd3ffc141a94a7851a12af026ffef54f2cda486d67ab538284c2f8f5efafc03f364792f330d0b391be9e72efb0eceb324fce608cd80f508af6921b6ca6b82835fc5ec6a13a0c20ff4734901f85a9a301519720e431cc768e72a8a0e966f44167dd3181db259eb467b531e2ea5f22f98192c7a4e740f1819785dede64b5e3cc451afa00509d4130f3007f14fe81233098bd2e02387fcc9f9c9f38001b377c384e2a8ea37487beb87e0c4d3804ce932ac6c2bad0b6397d95cde45cc47a4531cea64e75c6cb8ab7887b140d7222e19224de84948d3ec4120eec496cc6620479484be9be6072a6d601314f1b9cba7877fcc00f80e9d721a5c60446b62ca86a9896f92eb41cf8adf64084be69c5eea3d0507db265239741e7020eae5e85007a8764fb9fb252e3761b7c9f4f662ff977524128e98e878edc9418a3a503509a46709e2b0bf75a18ae591dbdee358dde0d9e58b854f692cd25739238f888767c9d5b2b781d0f343a1f461ab3e5637e2c65611993d08a299024fd6754d9e84147d825b2474aa4caebecc214f48ab462d953310b6a51dae0ae04279842fcc3bdd52750d6461d01bc6247e1e1ba742a74df6ad5c7bf750a599ac76f58bc7ed3ddaa983ce0e5ecd3473313670a5e05dfa5cdafe0df4338ad28bdd24da1fa9a8781b83417ba64b58fb15432b4d6a750424576c1473201de299df66f2220963de6ce0c49bca8beb8adf3dc184cbcd67e86586a74816d78ea726e2bc69f677caed79fafbe29efdf2009b978f1d6268e5b237e2c52916654d609591a17976e310e9eb5c2cca64602c7a64106fb43cf5750a8a27ca899a544636413fffa0cd2759300a265bfcebc3ff13f862fa41e974c9dab4114f29459abdd1c06ac9056a892c498c1c3d2c023bdaf3f87342c0b60ad13455c104f6186f724cc4c187275bb53891de53679019727603a644b20f8d2c754a395e0ff383e484119123ce08f7f9bf5bca8eac836ccd879daad4e01866e0db086590c8799c4f6006d0ca19930282f97278cb2a47da3ed65aa954f83738e82e8f688d7bd8a5484c95dc70366f4d9acb45dfc1599c69b625062b1efe4cf762f6f37aa5b1f8071c8fbb9cea2a8918576d0873df292b2e7c3a5a09637a91d418edee9b55672372618c964d1ca771f9d4494a13134ceede4256a23642f54e243826226a547c8197d536742b7e99b6fbfaf586c915c4920253ddfc17d8e5732ff3bf73d2df77c7e5492e439ac201bde92062d0c5afa179291d45c948ec7600defb6bf18e159d64f7d5bdf18115a88cdc47573a7398822a77bf43ca776fd61c2c1afbb5e843dc22ee74950a1c24d2b9ebe39b57995a7e85372171fbef25278425c7dcb8a1a16010a99e351a6834b976d44cb6e215cbf9dfe51f6235df611024b504ed8c00b3384c55c899707851711e72382775324808d38a69c4117fd9cabd3113d4295874019e8853c971b0ae606cfcf9429eba9375b6856f5b56fa588a964ed508762a6dbdbf780ad8c69d65bdbb167f179293f44f776e0ce5ba331c4e2850c38e75a20dfb65547f2e403ed232827aa8bc2287df6a78a710463c8563d61f82e0500fbd496fe5a36c21a6f34558f3fe1f3da7d0b9b12960de9bcb804b8dbb50f421436bb5c15937a24422e38a1e2c96fe2508c81d187fa37c146aa18e08449bfb9fc3f01d251138ff524a5e9650d80a3c35f01006b63f2c745ed4f0d2fcf6d7edbb64f394c5c162fc97518458598724a1ad20a1c7af77029a6221e5d1122cabc88555c3321b525833b163ad5d077e7e439b21d0f627dda675efb688ca54907fbea30d9df5be6fc05ace9532cc7700de2db709137c82ba746771ffa64dd38bc40506c672788f40739eea9e4ee89482907bab52dd55e4f299c521e6d5f24e53c84a6517edfbccf7e4e44175936cb81ab08cf042b432807646f70204ae7a72ca900392e27246424e2903884807f2f8f314832bd2f668c5b2c9f7f0c4bb220dff6aafd49ddbe7bcd9010c64e603ba46a29cb2553a45a54376b992c1c65f650de537eef9c58be51d5a218af033ecf669a518b6063c488f1d3ab0cedee0281d8929c4176bf12c905b12120d17c393e2155f24f902b63696a449a7d44d17c89049cd98dd6718276c742f362ada9d2889adb59e1129a8f417d8d71976b8f28958e7c56e1eba272e1430e82028735a4387330fa9b010849de453dd04fec98208645e95b255eb802da083972ba82c6cafe9de7c274e3c7f11986aa693da967c30576b2f559695e7627435e33171dd527c9e409c317b93077ee72ac5baa5e087668d59f068d5264b891d52aff42a4ccd7ca09ad526a9573ac49f2943687820f9700d55377db4aa9f3f37d2ba668042a5aea60aa413420455fcf16b8d2f640cbe100473a9be7e3f9fb6b09baa7d9b0bfbd633050fed47e389d7931c5803afb0eddd0180069616a42122a8ad15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cbcfea95816eedbf163e23f7de09d842"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
