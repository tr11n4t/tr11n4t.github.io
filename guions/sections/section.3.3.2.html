<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Pàgina encriptada</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Pàgina encriptada</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Contrasenya"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Recorda'm
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DESENCRIPTEU" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Contrasenya incorrecta",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"937d0342b1218e49d14bd7456e7d25a03f968afd509da15d16cde24959e96f03db3ff317db95dc203071f92573b82d0f2a58f897492316a78f08a62de40efc086478497f7e0de146a67b2c631c92d636338e03b720902b00b7842ad9441866177b99c3f785da8cc6a69be9b038137b11f9049bbd6551d29a6c73cdec550fdfea2f747fb37ba7568514a068c3bd2fa53ac27f3b335a01b14a4343663adfef0c80c0818b057ce420aae7ec8bdb672f0a3eaffe086bbe466d826de01478463630fd8a0dce91ab26d64c54b447c24bf6f6670f1396e8f39f7d58e363b70b101e04d643e1c1c6a71e604f7251d2b0959832d9b29888f4408cee14a45c1d6809be2392df0fa465a48774e982e1db687fed8de08b65a0b9045d8f73538f02f6e544ffe85068ae31f5e7f5169c09c705ed8f1b75858caebed2b6dc942211a737542ca8d658090a11f89a4362579fc99adec83da44b1789e116f250ec109faaa4c7ea512b9d949c72da9f7b06897162a9f6bbdffa308d75f6d5fdd47ea127a3d8b690d5f65a35399e42852b76f115ea7fd2786ca8badf3940489cc65e2fe6f53000797d44b7a76a95d0786aaab7cb09bfc715cec97096f7fad12ce4eafe703de9750cc2e500868208e439cd08cac36440d015a81a509f16f00c49f27ca8f0add1d86db9ac6f844313314f38a7650e8c458ac4688731708e485528d3dbce3cca10cebc58deff18d36e6e815b251497ce759eb09a3b0ba857a6ccd08b4b06a7e342b74aa8a414e6714b1af61a3837abdf83856f80a7a8f189c696797d3b43c9f4afcc6e2ada2ce3086cd89410e7aa2734e639c3c7e7cc6d8630d9a34c0110f32df88db8ffc8eedb667dc552a9998208d883d581585d7185e2166c6b0750c3313706c59578994ce2ae6672a00f26062d2c5aa737424f34b1ce998ef01cfc63d08bd9920062037c796550b5375c6152b0ae3b15ea0c958362a5c4700f2f807dbc64bd189513829dae9d3a3f56a5e5969a4870d62258215b104f582202b17927723ce6162e717779add6270655f5abb6ce4cf06918c14fb41dc921e99ec8a52efe970c0769a57a9651b804c4f730d60412f319891d17a90d68a52e057fd3b3f19da96a7eab817bdf99a28a3ad528363b032bb10f2fc0c5f58819a5bf12b24d1dea2e6c10d8ecd1eded4b6382168ec68f672dda7c10ea0315cd052557efeed18fc097cd491677868f40274294595cccc2edf3bebf30505a32da96468273122a70ee4574042f18bbc89c30c85973727ec94fc75a2cc151595989ee009cdc03b6b737a1ae6a24fbec6facab64697da51f2849450f09cde678579dd4e28e339809c1d85abd3abcdcc46fbbceb738ce661bcd2a9a52c51feaf86e2dc2cab8411673784e4c7a8d37acc421a9e7000cb9b178890e412ea8374bfb657b5fd2308c7127be6dcecb1c4a541752a2155b26c32a9226b214a8d6dd369fb1c69b6a7fc398a0aa775994ff11cef207d108a3fd3830a5a7166e7bb8b196bcab1c5af79e74d6af16ae350642556b29c3e686ac68a009476dfe8dfbf50017222325f5a66e2883b1bdec129446737bdd8e04ff5c89bdd5f5a4debf087317c85cfaebd34291c6c6d0b7c60ec6d872862af761699b23a984b94630b44a360543d8970e9b156b5aac0dc8e732947dd77259d01d50b53f69c44062676ac36b584d80ef86c854dbfdcb60372d4858c3c90690c5d8fe47d3a1057249bd2fd74c4343b146bb66e0d4f24391f8f785e3971eca5c02b4235fc91a538d025adc233414079b449112fa260daaa0981063fe222beb960314cd2b16cc335f4a715b766335a1610aaec15f2e26c4d79469a9c815618fdc5eca310777021ccfde88d10f4856a904f5c6608f171e6786aead92b5c66fe5cd7b33f94c59a3f2246bb902cfaa0e50f09855226904fe0d1f9894b39d1d10c7938074e51114861a8c2d332e9ea0210993b612c4e7314f6f7cef3cb960f01a1b69bfed582cc13e4dfb47fd4a32a08f1fadc4d03d8eb58ec220194921b5056a3d47a6f751d870123f045ff3c89d26013d331e39b7242530570a52f4158ae0e81eefd029e1daeea9d73d1ea47c5643156e3a1769ad1697da3dd7c53b8d0e7cdcdaf7c14582ac1b70afc85d7f239fb5f03d6da2282c120f43f5dcb56afe04f4bf28e9cbc8e19a80c9734815070e4993f4a248d82b82de417397d1dcae8183e08cdd8a9676efe02899fa965345b9db9958c38e55b675b66057800743ebea5b7207ec612a3c792f751dfee5f7413b18b19ca4588513f655cdbfbb1e05147aa64eb6d017669f7f0cb34f535563b21ee4a305e3829a90234afd1b7f32b8d9f0524415283bffda99b883de59828792f175202ccc1ed0fdae4f6864b27da3a6e83073a0f623e91fa00a7094cfd8b1b72460f1e16b6ea9b5ed8e8b481a13a0507031944ae7fb565eb07a01e5a8eda4510ac7b70ea4834064f83f5d373446a849521d933e3f4e738bb74681ea35cfbfacc2491b09bcc68c01e55ae522fd6abfc29e81bcad44d1ff2ec1ac94f1b4d6ffd0918e7a65cbc2c00e62b39f211ef8b1bfadb05f8140b4ce55bb1c476657df8092e0d37e4f225f80fd52774e9f44de0956a4214a606bcf97835633351e005c7cde00bbbfcb9280537722009119135e657d6b8d77a66e43339497115c31a6263eefe3b9e575072c17efc74c89e38e3f088e24a4e9c6b5de4663a45b59dbe4464e3d373b18618c96d6ce513f8e66c78c72618c7fbfc500196bc2099b37ae0f836389782488d219a21c48f9e6fb9bc0f70820b919bd7415f0c2d16897e0a7e6f878f9d305590b906df1c03e3d626f11172dac1aa3b81a62d3a3d66c4cf59a4dc119dbf1ce0fa23cdecd96b207cd6794f50998b40b571ef9682ac417c10b70bf8dd1784988260cdb2f0cd8a87ebcb66f61a6bdfa1e940a1a14bfc36fd471cd4d2cd4fa1aee3a8e5aeaea02d94540684bcd5095bd3625f5d9679d53b524b319eee5fc73306e5c394e018f4468b79418a7fde999a37decbfe1fd8bbd3249f23992da6d080c42d6bcbc526cb832bf96e1063e5623e0cf45daa98866e6567b155e3a97981b9780045e0ffede849ff0f8f0f0c7231f0bd0b295a3b2fb65ebff715310b149ad13f00a38a56c9928880d5f616c4a854543f957dc637815c3e10857027ada705feec63781d8e93ab74af3ce14a8780c8c3fb939290d1bdc92b9519cd8cb5d0411d1a555c7aa6fdf91e382163877453e609ab025f8c8fd411b66556392ab0704e0d13074942530fd79774227ae4ec0067e049413717ec0e5035b09032d203070d67ed2b3553b260553abda238f5fcf036e222a64fb5dbbac83dcd1fc565fd9f70766455fe019363777f1f2ee56e6b29e2ba0bc45730127456e5bad0beb6c2fe8d87081a8ecfded351e50fc8684efd5c914dba73f4eacd2b1191871f2151edd55ae16fc171b0e057b25961f9b35a1a61c76647c470eb108de17b06e4f8b1fb44e62739b0f9649edd09fb958620e7a7584a085e5f57cd15f395f6ad83f045af8e322dc5bc7d771e13416b5870a9892abc169a6137cd5e0a75490cb8de1ccc13bb87674243da7079d121173d636f046afc7397b96274b6dd2ebad7ef61e2feab2715025f9505fa80d02e0280306c8e0fa30e45403597867a10e32177dda79542a01d8af41a1b8dc4de57612d131c46c862c299c8fe441a185e0d9973657b30c7cbd21aa1438f6835b21cc412f70004e8b07bfcf6ce10ac18bee6c6cdadbf0626171a42266c1ece960ba6d434bccbd79fb283f7025f7c37be4c8e1c6ab2fa9d3880ea47a73e298ee5fa8c3605feec623a6b115054300eca75146d4480c078f0f8c73889b68efae50c2a7bbd5847092a64c668b27592c73be44166c4b0009d16c3ee2d43e9a21591e9b6fe49b56368c5b59ea86315c57f44ed4d1bcf3ee210658d8379857758de541b9f83d00b27f11704f1748eba9c48ff11847507f1c7faaa778c8738b4db081be0af7f83b49bb59d3dae4451fa3c82e652e53b4c301958ea4b0cfac4d912d1e915e8a7ff619f40d0d69c7da0bd70c3c38343b7e23cd718924688bd2d62a9e1596bf1cbfa8218aba9535b62fb13523aa72ed322a6dbeb1d5431b8a476d7548c2c6af20255820a440e2b000390f530b3cbe28810765bf225afe312681f3b945887bcdc33675281d84c81858ce11babb9c20eed3a85b72f80a7a035f276f616a1e2f2c9d4add7b5dcdb45aab6262d5276e9dae36625467064216fb1149e15d690779682c59ca9e4f43a25061979234dc9dfd228acc05203efd0c918e9a26044c892e506ef23b30e1b1486f0e2fbb91e2438766a43033e5d6f5c0d1c555310d26a3b0c94288090ce78cdd45c0302d9536c955a7366f936a1f30dd679d38200d7b6ea943fbafcc49383c6f0ab2404c1e864380c29e7587eeec235b27b433a6dcb01d1211efbc6aae3b612fb902f8fbd806dad4d0df87de4118ce53ac6e46ddbe371c7eb2a7516355e54c6f3f3dd8d5eb7a4be9652fadccedf0fae22815719caba69e39d222850d75810353f6ca460838533616cc5285f8da4e921298934e04755b2afbcc9b91131da045a997a58d6450967239024e20095db499225cf38703c2fd3de919db88b644c75eef88aa52809a09cb11ebc1a9da18cb0bc39d852799fd6f714b1f6ab3203124a096c645e3033ffebdc3a79b1e3ad60278683b346b58fcc75879b065e47fd5138552ea76200c8bb66ce805d02b09c2a21bc22634c642a3eaaedcf83c85179456d196d1acb01baecfd655f8676384a66c5f2edbe173a03daf3d2097f747372a905c3048a3e49212f42afd4a3a114de1a534a24890b84bc3dd9cee273871c058aa4d7235d236a268b561cbc98183ce4d239aa65282d108c6d01580def6d252c1a5fa135511bdcb23999cd32faf3f8ceb1bb096d37333663b1f06e585abcec7dce2a477ef87486da18028652964365ec1d29bd6dbd55ad2fbe588a0093c7c0f6a3821e1f0de010a1a7989f61b1ab1bb35124a678e3014689626f89f1f643e9a4730045546eb6aadd322e7de18ab2075485bdc22e18b69e683b737adbcc1504ed9d16e718f24db0e596497ef6d6d3e4ceff1a3f01426b53cece3d9480a66217f6ae99ddabb54d7d5e70e021bb89ea54c51838b8703f12591755c8700e215a05ae823f226e050d863673f8aca01623b0915553db358e30b198b465168e997ddc3446f8bea369c53cd02edbfbcd679e76cb23da10f11b7227ee66fa9c2ff3c049b621c6010d3dd48d41b1e0c06ab53781653f95bac5360111225be7c3d531668754e393648de2431af2bd29f65522d8df7e7fcd06b77f05458c9d6080e8153525927b7c1d94c04679452ead1debd90182547f52a86399b8a0b9e36794d8a91182e71c2cedd97b5187fb731da010addf24f82b95d2fd34947a0d6b17cf940d27ff806f661446cb1b63ae1348b1fa9e7c3468d74988dad967e54334c500ca909bd160f00b4efa1d4443dc9a9ebee4cc3182670a610be45614ec30c28c5e5dc588ae67422b1c52f50595f93322a8ad79814a6b42e0a58184225b427db383a3fd933877712ab755dde050b1951e5d2e496712ad2e47632430f07a38ff6d19437009511a707f1c305576fa336b6786cbffba5768efd19f658a76e9c925887b82470791c5e888ff13de3ba0e637551a1e68ff94baca41cc8eea3d86694eefae24f1d042dad4370425b7cfc452764d97e84a384edb2ba3fb13341003473013d55162b0b2bf25220863a1c362e7239ff4fcf731ff0c6786f5965692310a896012bd10bc4ffffc32d0a097e73b1c03beea3443af2d9495af4baa8f3aaa6dee26906da2ebfbaa681532f172b2c426ec606a148b3dcda04afee89ca85c09b8fba738ac156588c0fe61a9aed346be4c7fed40d112f0b490159084b85a69a7fa2ae42633612929fbbf8653e21b952cb40d12baf99d034ab8b5701508e67cb1e9c99798a96b156056cf3eeecb8ed07d495cfa82aa729f0f5b58964f5ecf748698eeba30975fa8685e7358169b7fa173fd0e0239920074337d580faaab7539d886d9ce7687c8a84959eecc94b41f5ff7cecde193d2bb6cc5d82ca0a8ab08f6ac9812c2af7566ee230e02505404354a263d3e48f3e352671f79e7e7a2ea539556a66b2cf1594b6cc474b078b28b816d228bfe21945dca38d5db98551aad3efcb1403e96b921620ab87c4a029d3a70a3f5b6ceb5c12e2d78f67a92685af28ae6def7e72ae5811acd41e480d80967ae6b2e1ddeb2ba548255515b7e7410ad3dd0e00bca5a01d34ed22c999bc744fa46b05ed081f246343c75db9eaab8ce0ad2060fb9c6c8244a900de923549b73e16739c4ea7caaac34de3cf0444113aed327533911f369dff3ede6815f624cb1b39b8c31064bb87ba4b3aeb70b360ef149b2da98748a145b264eebd6213187bc832d9686732eb91a49ff4d04d102a762781c0164c71de6f2febc0c4d55bd940f4ef7f92449d001b84d800add777a8c4956569557d9de9efbe18d6aebb46715aa01cf9aa2846614326c1c9fef10f390d6eb9c3126c569ea6516b5ba0517cc78de82b3aece2b47801b01bbec6d11b1a6946dcbb7a001fb4fa64f360135b520cd527abe90380a7d62e396fd0803dad8935745cac21e7bdb83be2c3ac6631bf8cbdefa368fe141d12ca110ad1095702531840e435392daef186fbfaef421dbd9a19141d8d5aa27442e3b0a52a1e780dbcac82c3e400771c25707d60492c331f606b41f6ad8e69a82273416f1fd166a951b1b653ec7effee00a732edb5d9fc258eee0841a24831bc9eacc2de740ef9ede2712968d1e00a39cc49c7f1a31957e848d732a9635b3d839f5668a9cb43e7a92bd15bd508512aa71ac30047d904deff222e4331b3bf1284723650a0e1fb435c0341a7eda145671391e8fed8b12096a9e48dbbfff6ee53e7da88259375f9bbbb1376896f94b4c691146e69d5ec66ba9090dc2a780637fede8f1298a07fcd276f8ed7bd084f687685fa462c9746401af40579bba5cf9e0c378375351cc5bd478ec27684a44745e4c783339c91bf7a18952b989a99a538ec775ce38922e6d39cad8f809ee1fda44036895064bede18b6100a2a29fc658c42eed5b9a9dfaceff281602f53291d9ab9db5df4cd250aefae794ff0e4c7a0189a246b1c6b4492f46c7b8a6c78cbc4aad5aed33b15c091a09928e213aa344abd621429fdb95521857340474c0bf8ca85c43355b3d12fe9b1df5b78c5fccd1f8102f6e77dfff0eef5888e49e3a6e06f25317ecb4dbd1a41b0950f3883db0e40c71bf4daf7b18b298cad4ff2ea544f819ae1c25b797028e54d2d182abfa1c7568573c9890b4a09b72516f51d3432fd1c9020d9f3f591846b492c7064c4c92f2e17b66750f232a97646852b4398486db34e92ca35edfecf1f8f5c657fcd378d393d725422af749180a260df24c886ea4dd0a69c5e0edd09b5e6abf4a2477b61c7b196822e07d45a781590749ab608ff94377b9e0c60d499ac39caef54c6548f07d4f2678c7486b42ebea6aaa14c1dd0b35e8f168e14995c10a8265043979dc846b2bf6ae5fa9d1a2be0e2fbf2aa1cf3c9f7ea7fbaa8902906784f87e6f10595f1fdffcd6bcbe663a7b324b23cd61e997fd7465d18d6bf998314a0f118b89d08dc02622c01717aa5a3d23e1744d46967be4d279055fed485393c86863b2ea65e394842d451bc7999e89497fed8cf2ade26490a899518ed4c668eb349a896e3d7c02fd5ccf935d92a26040985024370991319413e1bb2edbd0c69372163b8d728712787cd5eb5179fdb70f3e9ab3750795be118f5733afc15550a9e648179cf4cdd97552d1207c9698183d820f16d2c9feb006f1ac032c4a2c410e21942c4969a3240f21b3396899503972bb4b367d1ae630e472960982a0017485d7b627db0a4964148bef37d65b688dc63143e84cbd3941f842507c845ebc893d7c60cab239350358959ea80c2ae21838862a3993cace4bfa9abe4d2a7a59b2d20fbbf2d1ee440058d8358470a3518510a7dfd8ab320a848532f9a7cd2ec20d83aff99bbb626e97e8a341ce30008940274c64a9f3fc89014de3027aa3bdc586ef13294010f2c15bddf24dad640eb12b0f6bb573b7c2dda34c7687f3ac3aad4958d50eeb2fbc50170520766743c858b8cbe8b534a22c08327d91140d852272a7313225afbdd9144d3004c2d37f1372566623bade2555abc5a2d7e808e36b3a6f75de175ceade7caef0134268daa81b5f2c7ec2db2ab52e063d729a8873d17be4d2dd07ac893163057b24a4b7a77f8ae3defcee42165a6ef37e324dce69f6b2ce527839faa9b2b49aa1d9a8561ba47a8292fb6fe5203ff960a5dcfa0f97fab15e87b0e13c88ad346d9575cab8fad67f32e6f7384ef80e894b123e73c923071c4cbdced7bfabd3756d4cee9c78a219e20e3c737d2bff7049e295eff717ee15f47f7a1ff1ca82f1569baa3c62c6376ae6595351222f678dd2bb942156b98a44d28fbddbd698e512b638fae93b3f564aa781fb55422b807c0abbd8fe36cca81fbae1247863e9353e54294ca36e8a7b74e3edf700673b41a49739d3d6eb0a3cf0c3c7b1feb6b4521f0ff6ebc7f2db3d3513e51f0e4e58a163462780c9664f2bdcd7d4c563657733ac97a088d69dd1dcb6afc7b876b9cefe753f0c34a97cf5f56b87ace6f9ed9d66372c7c824ec9a90fd7f9c894887c0e4ad3577c390c07b7ca1669c7121fcef326b2492fe3a5c95e563d41f1c807c4b82e51c09fac094855955950f04cf201ef2a00c536a677462b3a6d63a058c4790d06da8d937cbc485e3840d6a315b3cad8f0d59b232b35542185a81877a5acfd00692a0faa1e9a06f44786fb16f0d70f2cfd9e98552d360e251cdc23ac7043faf8f895223c0004427d97a37266ecd9517d30121bbce41d0e5d82e270fddba91819c16c969a88b2c3e361751a41cfd75d400c7f50703a2a07238bec1d950a2cac7f3d2fb9414e8c632eb39003ab4a963908cbb77bb6b8ef27818d874bc0efad58c062a72a96ddf76008511cd98ad0236a692b774c684aeb37054875d49cc129522f0f0f18babbafc5eb59374de638ddffd9f40d737c83e252e9a220a8a8d3f242ee5b6b3f76be22ccbaa935d97d0c4795e8fc32c998f19f0cbc254a05b56ef76aa5b03295eae0f0736b0406f3a664ea7cd66d3777f39cb217949c54841e1bcdb62cc7e78b6aaf3dc01bea33492d3115cfe2f661fa5caa44975fdd35cb279473a85dffac77ebb87f224d7141fc06598061091e953173c80672799f9039baacef30426d8d1eebfca3d7d496bc3e7341e86813c0245377d4487a310ed1973b903d4ee3ad82c15437ce1d3c1b7aef0713e189eacb14c24f161f7866f6dbd464f63215040c120a78e50f9b5a9414b79a109ef8e603914664e6adb8751d6603d2e7396fed839387c534b863cf59def8f7002e30653ccc0710af81c692dded0b667d7dd66a6aa4b45eceab1081349ee7c237145fadbe1bae3d5043900f4f58416bd388fea754412acebe243a03257117fe340883483369736fe54dcf43144c3f56d71eea29d332746c60220f0000af7e1a342b825a68bd9b2bdfd6039ce8cee4084836908b79e865da567a8564acca85a9adab91f1e0a54618b0c57c067b48c716d440bcd6585f33b0bf38719e6d8f73ff03d012ab7d22dc0a5da2a65172b66d36682418d1dd502a5eec4ba1c2bb81c8b500c30d4cd462a248dc2a292768dbd10ad8847282824f53067ccfa1f67a96e5c9bc24ee2b2c59c155e8f16e976fac44970d3a5a1a6a4aab98bb5280b655762d11a20cc2dcd577faa5854a465bbeec1ad411d6ca8de8cb9e1cd245ff81f51368cec57c2740f462fe34d5eda1d64257f8f7c9dc4fe8702955453859c21c25fb143fa44f7ad1ce17e499e17f78bea0e151450e2281446bb928f8186f817fa2a4cf31dd4957207b458ffa2706a021c6fb6d5bf51a2bfa099b466fdae5b8ee5c1f27de740816c0da3d636301f70099d4dd80af6af2166dcf9177e28a517852ca8eddf745ec35c659ade75a22145dd9beaa63ea8116c3528ac0dee3930f686d60f1b31284a611e1a48ab7cdcde6fa03d3c0ff28fb8e06dc1f8e817356a52466d16b70a5d110d12d470a06538f98c2e9cd4fbaab7ba7fa1564fa5e1cfb1503374017a67281f901c575ec2697fbe210cedcb381f0851f85d4a619a8f48f39cdde33fde30d182994ce6439b2203c4e9eb34dcb7b56e8b8292be37d3acfa1ad190ea9a27ce73fc00d89ed99ed720f00a87fdf8ff6f831f79ebcf9a2b88c2a1f4da769ea4c86146d0466b7c00f340c3a1c9ae52bf23585314deed05a19c9aa1f11f53633f2bc8562a1746cc327436e0ae0c17295e6a9e80dae8e7698fb6265714e05f858dfee380daae41379ab42e0669e8c05746e4507ebce755dc48727397799f5e188b3b5995952306531502daa795c70a6445a79755a3a79364257bfe9b7fd807da7f730aaef96523e3ba0109a2859e1fa6e5711dd56aacacf38aec0a79adfe94dbfe7542ed4985a04cdac6d409c0e9a3526f50acf19ecd0ae003b6047e5699559b493311abfb2eae6ea55e523e5be9a9786981e7a9feaf70a355522ef78259a455260704c03ef7ad59076f459330852f6ce414599a627757d56407f29426fcdda08502d91c249fa411231d6d3c077b0bcbf012de69baf6372e3fdcff294428ff27f04831b65d87db9642c6def233921db3c949573bb857fd3be980b5d17f433f6dd8d6fe87f2bff683d734cfee82eb4209353ace9d7944620ebb6987c9677e2558fcfe7e95ec29da56d3524a6a4914502ad7a231961e52435c937b431a8768e392995468b2633e0df9728148d5ea91b86971e519c5386fc42a7c84c49a68e7c1d4b8d443892f7f427b5558f8a4307a89ae028aab1f0dcdf30283375d8f7cc80238bbf0d66f9ae724f93d33e516668c7972a9d29b77b8b2303b46a4ed2554e4a5ef8f2f6162978f728fd63c47aea92367585f064bfcd3c9c20bb3856898858b7191a93697f21564038bd64bfd55a475dcdcf211b85b8d6e75b68965a37dd0a05efcc532e53e578c43ce3dc6a10d675f9d287812fa5cc41a1723a93b48ed3942f400f17dde816a7b4812f86472d028827bc9cc71e36a5f36287dbbb0698d8de92b21d2e393995da317e9634416f2f6c4931e57f70f712c1bba3613b675dee7a2413419bbc4a097856beef9f10a0575ba6faac5238f4595b55213931a4ad92853dfdde0a0a9a576a660dcbdbb7f5f8100266b46c74809cd620b3e9338c8e970c68bc5746649c841ed2a8d8c35e6a7954e349b0319af471ec9a1202d0327624eec6531a696c7c29b80cc909b302e27de0f60778894167e9de50026d0d88a75ae67d822d1cab7cb284a7b134be5c3d5b2389e9154ba272f9e8259f26afdf02a32592845099f401eb68f880dbb185fafdc0d9bc3156cf688570d9f6fabf7274d6231b990e71e3a67304fe6c3742f909633ece773c936158a25bb451608fef18d8e7ce5c982963ce1e4cbbdac0210786d0e57a8c9acf89fa578ab7f335f04f8d679b42f5a9bd413f42339d6efe93aeb85b3c352786b81123e1e64e87ed4868528eb74592670ba21fbbf1ece8aa991ddc33e4aa631797398521304242f9d29a09063200e211ad88efd1dadff492d987d28af67f86b7a81d7d46e82ab943f8f74b8e4300b98d9be718d772827231752f1f6234774899d2f9c340c10aebeee02c32a7e956a0d713e8ce117d9f077f217c5ca9f210db9fbdf04013c715f1d0878e3dd036a25d95452d1e24b0a872d48eeffe640eb700361a7ab70bea8d686998846236b80e31f73881022bfd4bc41b8b0bf75d0f6c0f8df64eb6f423fa1888c60b822e4e1abb500a593172d1cdfa7e07fec9fc2e4b2738b676554f5f1997587164dad01d30d7f8113725197fdec7b14904673f0686cbd0bbb7aef414d45633965e265755d9c261401422c19ab5d2b003d021faccf4e4f0f1b0fdd76a56c682f078f5cbfd4f3ff63f231a2d2197a17fe43ff826bcb5224a073fc6fd0a6851a5fd2ca4b1b6a7c8295ddf0e015146782542251502982b448738ccf6a0ac2b257c75fdbca5eadf785ccfc528ae6b83cee3c6d155dcf37f16d01bb0da4fdb40443b29d08f43e5c30161e4b18eb0702069cb654eb32a90cd01cf657ae26fe848e1ab8984fdbacdb22a82a0be85638c89e311316a3d576367f073c2f6173f0821f1a28790ccf14db62dd9f7f09534ec091211e6853179209e8f75d45b59f06d3e768187ee26aa2884a2b34886c4b10229dee8e122887bb45510047a68bc04f3223182b01749d6f096810e372f75e2bdc73784bed4d52b6270b81a564fea2936476a0d38e01f0190b10abf7030434caed3953ddb2239803240589532b876a6716695cbd6c9f3c8c40cbf60caa79bd65336a52bcae4aec3a15cb34af666397fbc1c935e960f1401430ef36722d253ad8ba2bbc29f7436e4aa61fce41fb8b5c0ffcc514e7a40334f81661ab957ab89d700b4a807bb4afb169abdb4839fd29f86f1f282764438a076079a9cc7035ef83bcb68b8b9859d1cf047ee2116bb8fc2ad1a87d2fde60c1bf98325546ee77504f6971a07bb57d94c4a79838a44af2ff8fa23c3d601bb96f22b7740558d570eddbb0c4c1a98df4a9825e36ee2ba83e08c459da956135480674bd75492272aeb95e082a1e1bd9f373b2f2112939939ce3a4ae0b52072d9d9171229b4b782f6f7ca7797b2a04525452f07d4391761381634298aac9d153e4a7e882938c0b9f60574d8f3c04289c67770ef572b07fae041a88e78b588f204a548a1ec4e8cb07c0894eeaad1951d3ab926d3efaacab67639a4c6ea8401dc46233ead08c0f19b763a8adde45adade9ce4c2354259451556bfcf0dcfb5de254c997b8033adc87c325f9da64c4bac396aeb25e05d1ca404ee143ac2a904baf653a9dea4d07dcc18fb53237c73a6c0d36c45745499944d0abce0e43b115039583d348c4b59f4735795ebc43bbbb887d421133a2b15943023009a5fa4b34787ceceea9a9d3d01e4bc68ff0fe0c1208d7192eb5c39bf6c3fa2c78b108cd913c98c6d8c05a071933ae4e8ef6c0d0754a6bc56feb1b10e81a9673f779855060c3a814a38d0d03408f29109ded92ad0df220ae91ef2bac33dd160eccf8aabe387400fba2b1b000fec9b0024a23605443364934454c540d58040f1cd5bb6a7066cd470c68cc30931c2f81142f1c303b7c2bc70975f672604413db68fcdc13389150614e1292f926a772aa8f855510d1f86c9d1d5c860ed60af0c9f06805ef37b8708f1c7fbb2f6c5dc0030adc74ea9c4499cd67dd59290500eccf27d3f926ccb204eb2b0804af564cda1dc29925b44928b005cf9326c6f4a234cc685b856e2a693e08420932784202bd6738d5acc783da43e523c30a354f8f08d1dd87890632e64f3d4429af1d1797590d323466f2bee38367daf7c34f59a6ad50a20d32430f6e89102bbfde4dccbb6b2b797e714c43d2e19b81123dfd05cd976f29e6ebffad8734db5052a59db2a0db83e23266ef5dbc321a8d3b9e9b636b73bc886cb39e05ed32c86b9a46b680189eb5547d150798546ab3ac07c31c22feceb6af9abc17a81970d70c3e2bbe5e691d9fbdb918df1cfb0f232fd8f37a4cd47b41bea62ae27312b79b847133eaa7fac14855e4d2fdf39b3c924f7af526f1cc9ec0178a9f766bc0d52bc95017ffdc284497561ee89bed82de4b7115ddabf280be713d80304b29ffab63a9bf42af217645d32772e92684fdb83ed7926822ac9469b3f89b91fbac24019c413d32351f90ceece1479d754db9e7258e7d74e7a80ca4d36aca084e20fb2f4d53f9aa7f753d0bae8e9be219df5e867ad3bfc30dae723514ce7d002ce255bb3293f22b9cd3b0bd85a2df9e3a241be34de992c6b037512dacb88cf02d8305d8ebdb1b1b31aa80ad13a2894e55f3a25fc68a772b7520d86428feb26d5a60d26990372394c3c297ba59307c8f7f89df833811ab828e04802a6b9e91256889b99b99d3d2fb44fa52944015b089f7a67f52cbcf2aaecc43020335245ddea4848f00e0f4ecaec5e1e0baf91dfdfb12c5464d1f7e23a4b2916d9e4c3e7cc93c4e933a05346af706d828c7baec89c349d66395afe8349a86b9fdb9f0c10f57b88ed17f3692285616797dd15534bc4383f6a3d327ce405c030f377c780a931794a9e4fdd89f0e29396fdeff5bb7f4479416919a66370305bf9b97dbb22639b2498f5cee8c5ea3c50145492b69f8a28828272b16f71e10cb41d7f6e880b87781d080524baad42b1c70bf7d217ab40ca0ebd04a56849d7b89178e91d06b8d0866999053593ab40061a226dbc5521f34c1dc40529be6d2f2986d5c33685c278ef2fb81aefb590ebe2ceba5f87280fcc26f4139d6388896434b6c2d31ec50b96fb9f0a306a86de08c0bbf0b0614dc2acf75778028a49c38bd12351ca571fc8c2c75a3ce2e60646f3a61c49e538c64721232ef1c507f87066ed931cac3441a690b1c59b2153e4e33e2b2ec159eafceaa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cbcfea95816eedbf163e23f7de09d842"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
