<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Pàgina encriptada</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Pàgina encriptada</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Contrasenya"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Recorda'm
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DESENCRIPTEU" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Contrasenya incorrecta",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a48385a2749cd19130857b6e7ff5235981f0f168633c2e8f230b163929f750f158cb1d3dee50ecb5e5cce4cc71fef5bfb7924cd0a9c4228f62a70ea39743280d688c29d85399712bfaca9a91b32f08815573c13350f201014dc8bc88f1a24303c70baacfbc1f8067c5b2894f75577b23479f0957cb8a266283d78b2bf7fba0c0e91009f66470277fb3c386103f348fd0c8cc228275e9921b0283a6abe525a15248fc2b7bec217b51d503b2d3cdce032ac8942dd025395420f4d9f43825fa0a39ad090b4abb66de374081e8ad5298ade0beba0ea0176f29c3fdb45533303ad084ff1727480c8bd0f16db4c572bcd5e95ec801baf89d8a99ee9ad488bca9c805a466c4a1ee57f4179bcae8490a7a5bdae11accb18e5d9ecb500e322fc25a217012942fb9ff4d4ab09a16f6066675fb1505afa6be0098a4e731dcf62510493be4a04d51b85f28dc0b93c7a4381ef8107603a7d304e5e013906e3249aeeaa5dd5d8b3214f87a84599f0bd41397626a4db587578b36883d2b71c831f50094db4fdec1a86fa007b73845fadbaad99b4fa6bd8d9345c250787d39fc0959195eeb9c06aa2f523e89319c3435192df76cfdd71516654e97ba0c22f129f8b5be552c1dc2983dbc170d23c98f44b3b2c63b218fd21c5e64f0e6537503a0c14efcf70c971774f9503dbd127fa1ad1340b199224d538af1661b7111a431b9dacbfa02c3cbbd0a4c9f984db5ce39f8365f214472932fbc11d733098c76c0348859f843779eeaec6740fbb215982f736f5b0683a0d4f344025d243ca1381361a8a7cfe62c55df1ea59e4cc31ef3b5f36c001e4e5f2510f27e85ca1bdeae7de797ea4283c0d8c23f1399a6cf360c0363637684282e5d345090fcb57eed65f1283b9a72ded3b0d6120f6f5613eb0e5756ba453f447503041177b01a2fea20c2a0357a03d8306ada58eb02696dfa209faafb8d8c40faa54f293ee78a980bd9300b29a438c9bfa386860a7c6b44414a0f314f70632d62e88e40106a7f301f581e30a19052502ceccdad5e50b8495e23dd59284921b9054c53ed7e35654cbb0fcb6200bd63b738afb13ae8775b288ffdaae31cc4f5e97718cf7b4c6afc4c607f0660026fd2c4c530522bebc041dbfd28e79b13a25f9465e47bf87d3ae10e3a1c9a62c3fc5066f6212c10c89bb809a0c2e5f588dae7ac73742a66ce29081c061b51d7d468da90d18124179fe555888fba0f855a9332f20a6199b5395569ed80e283ab8173b4e3d15278039f2cf33bff2be6dc4483946733526c020c927f745ed80757c020c8ed3c67dbf84a18134c9c95a05954f376aa130fe93fd1af0993356da249876062b603858b9c61e9ac1330e9bcc78e6684f5872f0a29c6e045ea08c006da1c45344fc138bfb17367f9abb35a73c1d3a45bb6b47f828e91283d33484f8f1d3ced773107bb415c653a1cdb99b14366ce603b10863fa7f04202e92e46e300cabeeba12136007d88654a5acd1e66457ff335c0b92eae86fd3deb840127e90096ebd9b9668bb74ec20dcd45372b442fd9f815e0c3b59bd55223eae29def6aa4a2a175b021ac9ec92be9155c07f7576a4159ca92bd81f6b2523c6f5b8876ae7b222b542a3e4c9c4b2c88627d7df2851fd34cbadf778b83110037ce8f64b0a2f34a6540c1a1897f11adc431d88a2b255ed9999a853f05caf5cb721eb4e9ae4503775b2bfd16f5e0abbae5e896c4697e503583bc1caab1550ecc7a7bd7efa4736276a7ec21349f0967ada71536811229a66f4a6a5430f6bd8a0bef5c4bbd8b7d1b9ccd6822a1bca268458bb65497be7688d6adacb0f1f906064e47fa60d420f83211fb402e512f2c23768d82825a46f98c0317a7c1542f460253ce0119469b647b52b2d973d388ab7cdaec995291731b2969f60dbca6dae0a37631007fd19e82d20fc1a0468a5673782b0197b5e5daeec297d3a2ac3d83fff53903992e1a6b69ad95a277599be8ab6eb764682a7fb5f3a8a7fa2ca8a0a456ecf937de890b7396eb62c124d2ee43ae542d16c20716c55657122d9af46e42df181c11d11552c81f13e41875834ccfb77d1671e6e05972455c978cbc85a66ee11231edbacad2ed839bb3c2f49ffad40518542c41c4b65c4bc2b2e3e8acb0c76cc1f06a810c4f6581411cc1a681acfadbe4b068e0588ec103e780989c5adc148c5c1cec6b047ce75cb2e18e79e67e96030e8829e011405b1fc72cbc545c27bd6e9a4963d39b26131d0490a03a1a8efefe7227ff710878d332f25a05b909c528176746013eb1be2a8ff4dfc157c7c2344b77dc4ad4c39e3127233763cb951e9e629258f93923ee86a17b3e01a669c32e0e56bc12a03afdf45fcd2cf649ccd9e0db2cc3218c6e90fcac91b58424c6ce74df13d74cdd2c550bb1e2b14e03d71ab81335a8529646fa41d7f2b875f905667baec2207f8a360b5f8dbfc4d6c25575ca34a3cdcd192e1ffd6cccc5ad5c00cd288e09af3db9dc33f74af041f4821a60ec022321c635cc5fea3c57bdf85c49fa62f4b5504b8cff4441640501e7467ed712ecb094e314c3089531d20a87a3d0227c0b121e4339d31e2bc8c4ac9c2fa0bd0c3204d39972c26442cea3465b3612d4811bf48554f1a07f785a2a55bc44cdc7c095215493d57f03cf0c1b4131ba772235fe0ea890c6ee4b54a6dd50254365d1e339dffff34d07593f49d2a491ca7cc4ffb360af2bad7641c54e4759df5d720d83b376961494dbbe695f92bb9241d41a0b3a276f4982055761a9f2c2311d27720ea6aea6631545bb19f567f643afe02ee82fde7989cdbb238394b7fa28d57094a058d3fc6fde8eedfd8739940b50458280e965671d43f21971e760c9d461d9ba4482195fe4aeeb19e8626390e28d34559372840c2ff05e32b6d1e1c8e906261aab1247f34817536131cbb70fd0789f240b9fee558fcdfb60ed18b48b51728ea13298a9f4773fb195463aee94ca60f7e306c1fd6035699614b7becf62440f17b35494015ea3624f2db58a9405064af0f9077ed563a603f8442eba6b054b3f9fd08620f756935381cfcc4c8f99bf587ba0c73daf32ce27de6318f168ecb7c776b02fb45a533be6f85f406b45ad5d8d753866b794f2b5cf9fd6bc1aaa20bdb49881ba0cee41a8eef419ea91af6e2be60054ab6ca5b7c8d444086ae362286f2285251704018e2a416d5b6a9ca67a14629b5213845cf2843c4c84dd0d8f47a5dd11eac46fb34c8ba341f051cbc940c61272d1672e69b1abb439459cfaf241c4c8ac192bf576cd857e1ac2034af475b2fbe674b527a1f737c7c8c24a7bd0f0ea494952434fa224f0d452a8f8be6365a181b936648f4ad3eb585b2531a5c2a37038a8530249160956d9afe44f08943c9c2a4b5e06f196a9d42d35c7ba80f012dba54aca7f961a36bbf0d8b8db8f99937300537899d2dfcf861343f7f7cf51e3fa4ab5a6a6fe205c866db31701d7716b3d54bbf07c20d588c8906b4e7a44c414d0796d33a64f2763028a8f9e10dea82b0d54b344bb436d404153a1798cb2cde330686b816165d08733f09c029f5c16d986404d4a935b1c81a0315951f27d0a683920f8a6e71960bd79cfac724e1069d6c59c60b83822b8e239e9a50435f1ceec553da3aadfeba8326a22a0e445800acd13905ee7549a494367f3eaf7d1bddda53387a110c98b95bf59f2ae73c872ec6691806f568a65d63327fbaabef263c93d1a6b0ac7b869368c042f2e75262939de8163f6c8fd84b4e1f88cd57f346ab5e384e70597ed31de2ac572e8cd6ece157bad04bd38ddcfb3d9702e2a9694edd6eab1764c285114ce21c189f1f3d5431fc4ca60a6721d33826b32fed7218b29e8fc95a8316855c82db6a60b45f2891205803ccbb3c9b17eaa5ddeebc544bfc5af8722e413c8bfe22d93600f5ea4bdd0df96d6896461dda21ff69c00e84b03fbdbee528caaecdbb893ba6ed9185132d772a9390b20aeda0ef420cd799adab743d8292ebce115658e84cd95e856a89dbeec3f165d091d9fde0eec810dd7d943c23ee5abd9bdce4dc7f19ce27e5364138b41d689103c7f05904e7b3925d5d72ac221beaee9d91606e7bed1208b6a62bf3eeafc668a641b66b47bf3714d09b6c41221b64c22e119dfec377477e4745093f14da843080c3f1a8b6b89a2a79020255ad7d08be6e36b7f251e3b2e3dc6d9d4724bc3ff7c471f564fefd70f46467b869d51b810d7809825c34a07d617d1551768c30a3b2d52b4cce738cd69d2090cdfdf4dc9fe7d0aeb043a90b389259558144adda6622130d97bcba1b98eaf8017c8010fb2a65b237895bfa4511326f46d218c09247ecfd4fd8bab74e29a100e6a2decad76b38e323b928c3473f4856dd6fb448f5ffe4f3ed8fc4e95a6e49b67ae796f56a3f0d76713fbcc4e5aa733355c0711784be2b8e9f836b5e381ae12c0c4bde72d8349266b868be17ccdae7efc965885e7bac2f891d520eaee660ebba0d7a6e771edd5a0892d2f942f10b530b5e28985a7497c35af0eb925fd768cd959763d9ae331b72d91d05e6a64f911dec5e22df5d3dcf512ce91677be3a72857f43a5a7e21d739a326d8c966725e4f98d09b66a41abab989e7747e1d16df2225053431ca522b8b9c5ec796bfe9ca054e1f044285813b63eebdda8a2f5d2a4252d896611ed4ebae5e5ded5e5ba966f29948abf5ef96e1b5e1ba861329c526e9906a3db5bbcbf29204367b24f6f2f23000cb381de8250fe7ce83c0aa20193e5ccf88a5ce1bc042e943244aab79295cc28c887c5a9b9cfa994bb8e67a0b0e58da320d1a138e60a0e9bfabe9d1e99d8a30a3ee04d9415edb746c5e69f10a314506a7c05bf6767707c88b32013e4f73a388ab2e95813f198f325553812fa23e0172debc29770e48840e689d299c2f4ba710016ed46956d42347162d1a95fade1c938011493dc5242724256ff85b5a05496315991b9fbd3236cdb912f18af61af0805ece1cd2db0b1dc9b7efd9278dc8bfef8b6a864b284c2f193723908fe263aac51880cbb0f912f4ee87c4ce44384891ed918d695b2ebfd8575a50db2d064e5006966ae45e7cf32ea3d878122639d0f5de4547b3f5b92f336269251a11caab7f67d5178d9e92e4fd1c8f9456866e49defcb4d87ef365fef000e5fea5271205b167144a12e2e57aaae713c32dddf13e067086b619805ec9f300cb671e50c309afafbaa62d046c259a00603c54ab6956e48ab06045e51ee0da5aa0d3fdb3ac239c0b0f7ba65d9016b50db2c69cde453366d10d6b9801845ae77a0efe5362322fcc82630268d21edf60ebe735437405436057e1613e2b8e0ab1f62a29fcd1501d3517141a2a621bfd6fc090843b4037d8eb653740285a92a2afe3bdffa32da2fbab88b9267e1611b535e0dce95fb2d49359eafa96720579c27c918b196291d2281cbffe062fdfb8a3e95b148ae35cb5506679f2a0a3b9d8d57de6beec2bf93d2332e6ecfb1b16e960ec0e4253f36943003348a21e1d18a46f76b0ec8aae07d60af4eea06f8dba5f93f971488e75f06442a049f667d46af05d489ab740fa02d63f16c7db4d54348f0dae6fe6657a6f7967f885a241b63be4fa69bacfb1fe9947645ecd77c450e08842c8f4bb4000e1a7e6c191033f37669a84c018eebdb6783164dcf67138e008a129344573dede6213c91dafdb5a96b935456dbda963c2ff86725bd944364f47f927b21498a82cc212783d5add7824779521e4419bb2e49f4c7e3ba98679c9edd64d52bd7cfb395cd48f9a29687076666fbe0abd7029ad235507b6f3683e627b85961eb19937fd510d3ec1b48d48486234bcb4c398fb2d57f72589ba78ace16a74571eb411d49b09f39b796f042c8aa6344de39cd9960d1fd3ba86f091b87fc338d3147d93d82af3098ec8f4b38fc75956f078ed5f536f5f579d41c8c826540b1f134978fd405655200e9cc240329a12a1f324621fa87d5842838263cf0272466b5e5279f9c7e7083ecc65ec5c85401cc750f3b0f99d9c74f6e31e65160e19bc5db2985b60283d487194a674fde0c6c92cc75e670930548e3caa2f77e2b83060d4a4ea1f9ff8d527ee2a66e098cbaa9a00942e4cf9adbc53e185f82c330c3dedce671fe545de428fbddf254cc96f07166381d6ff6e6fc7c667c9417f901b09568ea58ee914e1957bf631f1cf84b094481263417c284ed9d18675eaa99b4c0a442ab9a848f24a36a2763c82f6a8bfa48df3f6d46ffc7b3453ea34e1a0f8abc19805578eaed669050982c959b4e58113d119c091ffe83439622d1daaca2690823900f7e2c44147c5f26a2ba1774634eaa350bc5ff5aa999d364f3e62f66a6b1e5fb5a1b7116664ec043a18805def16d0ae0b592db144b791354fb13f42e39e51a2ea6fc8177c10837356da24412123ba5a221d94e2e47b164df51915073d3818811872729ed1f17aa4bbd0580be61e7106e39f06b43b4cea972d8192141a234234af864477ff93df436ff01b60af8ca53dbc7b986ea34d267b183b4c018fee022e66879c03d0c0a9ab64df497ea170cd3ae8496351bf3b4596b35f0f96da45912aaf81dab9634988d77a805f2018e84afd96f6cd66734a0ab03047fec9662e476413ebfec1fb78f027885425a52951833903ccc0445be64747f19adb6fcce6cf7a6efcb9f30bcaf1ac83a255e16afa8a1dd3e01b92f7301e1165d1289bdd39fe9c5420c248dc062983120c03ef6306571c8abb55fb4c2c197d45f33836f6f2e501392e0b1588a9adcee4e2bae9a63efa96f6686f52d6fc2bc90790af938793ea66af73c01631ccd47604f8a54c062c0c4cc4ac7ba361537041857f5a69992598a11012c981c001cc14a58b2633b06bed6259e4fb7788c059683b8a05ee8ad23596ef86dd74b18e5f1be7ade61664c27f7f63c3329dd4ebffeb8ea44afdba731e389b4d8a36bd50613293afefea33e73bd7882a84b7d85b6cff90b67b7e5cad218b89a0b511794a6dcdd5e4d16c68305b8b859c1efc0bae4373dc8fc334b9928a787760f6c50766d64d25988035b07abd6f6d36dd4fd0a127428f65b5c48dd46e608a618fd8ad0f0056889decf9969009bae635f8026f107625bc9c6ac4c3af774190a9ab820f56b879ba3b8ab6ec716ef298c9ec2b6a013797b14d2d9295c600c40458c66f626e99470f55ff543b5dc6a79a93c172e7dfb7398b5f19421a0fd85e76001cebac8191398b04e4702c08e90ec2769eb50cf6421689427e62a6c906fe328338da55d94f53cec49963ea6cf2a1985b6335a133150c2344a3e76034332cdef1dfd458830746e5c26431967b1ebc37b2857f6ddb7a0ece41ed189c080f6c8cb43a8af129e5a16e1aace9dcba3b1f840d38eed1d749c96c7a19dd73935b48f662805d356c94b8d38240813db2d8b2a6142cf065df3a45d0aa45e0d67c4996d3fb0c806012d0a0263544116d3907658477689b5c785b91a57afb42991509017d94a84b266e0a3a49293fd8d791cc0a69154b90ba46c2930fbfe08d61bffb2c3325ab1c46525a0863d90988816adb1fc44a911c4b5168b16d592565f183c19b77dfafd2f979518893346d6963904b688296c04d5d5063bea1ef00805b1566755e6e6c6b562935914f0cca4386c7117016286336a79252a9dbe133ec55fbc8763df3121242ad206cbf56b0296257ce7daae474f9441fdde0d4e8a97caf2825c4564470c72a60bdc3bcf91c602ef4c7415bda1abe032fdbd9dc4a73805591da1f7e42a5baf77a8efbf3ed21fb6dd1c4cea48c062d089c5c2181a8ed89abeb0fd1ba8e12ffd983a113459144282af44b32c06384479595c9a6000c07e7fdab2e849580adc377f088ca03001c7ec6b3205cd2ebdb71fa82c99699b8b27460e6d2667236701570c2e3bd1ee962b7d1904e1426f3be07a80d0bfebf475f85d818247b637eacb2332b119984324b1b74a82d2bf97177b75847d57d526807143ef54b7db597b191d8ed7d62af10c2f5f1cd3dbcf731352f1092d34a6a6e2fb8216ef02366d92681ec7788445bcf38cba3d21a7800bf717f99b5255cc7abb1860ca4e74f0e472a11dcce66ca9729514fab270af5809fa6a9210a389ce9e8efaf3f7efcd0a967e88a4ea407ce6ab66a9dbcc2bf67b9d24ccfdead19cdc885e38ed5d3b59e2e11f672c89fb19c5bad275b56b3d7e5f68a791f3756bac8bbc38ad66f4610108641dddc94fd546ed0abafb6be8ed17ff508f4eb869e3803f33c3e30c5a4e1d513eeb6465edce9a6e80422517a74481c72b87f5ea690d61259645b710464e6a07686fa0a57cb6453689c7c8d52a48436bb5a54a8f2625e6a66a298220cbaf29b3b2753b20c7a567ee0bfc644d80d41dc0239ddaa202f73a4bb04b849d9f718b11b5de4b6b25e9b2cd0f978fe34cdef4bab5a8deda6839cbdabc7c1ca8b8098013e3905e3f3a3ab8c5b62c14a3844e46c5d767b7cbaea5203d35b3eebcbe576ffd75d15117a0d65069abafa250335b72a5796f223a832d6e6ca68fb2d168d90a4f4956364c1d82fe5e29f9698e813d20a3582bd7f3fb227a7916d8f10f9a0a89c7f809722b04123a793817e306e3676c1626ce1e995c150c4b4cc8997a0cf2aa4087e0eacce90edac866647e3e38a824133f3a2c32ff278b68b90d19c9b804939fe44cbde2ac5bf802d74704be45e369493269f7275a1a3d68115cea9dafad86c3dae15322404727ead89fccb3fb4e4f77c23f05dfb474542328c10a89ea8705f542410c6e22e82667e50b144822fb35429d24a15a7dd5568e6b021dbbec419092e28929373c7b8e495ba94cb92514b3ab77cb1d4effb5899d9814bb28449197bc0cc32a417d46e005473e1726b09394dd5e4634f359fe885f4a31f537fd8b123da47f07ab3dee293bb54df87cd8cb59e4bbcd2ea9e9db90ccda815c1dd45bd81a9e814ea7cf7d80d5e05f8e1dd0d8fdfe4cac92090a0683352fa009ebbeca46b7fa7b5b3fec1818061cd91bba51d94b55e996bbe3577114d862f1eb5e5b979d2739e491b15e3167082f438f423195755cffe42e1e60649b9661853f577d5e42a31f42b079d8379e565a10b738944dbb28c8d6c6a4854dba5bdab908d8ddf6a220d91d0d5dd51ae82787ec5467d4e962da3a14f06fefa521e69ab068de71e1699951401ecb711f0fb015efa61be183f8480857cc716ac816fa02dd4664ccb5019d84661e8a032f4de846a60f9791d5d37b831240686a107db74302b6a00cb2f10b444e8b59c819d597005c169ddf683801c5a3a7ab063baee6563c9f3bc1a7047fe807ec2abb9be5f9dcdd85d9f45ce28e38a6020114171d601908ba8ec3ff852e06dc0c0e1a8ad178c089180d6fc9fd710019ddf0568a3b6149d3f38504bef44a5baf1fd4187ea70be233006dc9fe4c8cd6f7b4013dd609a7a1b6db091e730c7b029b543d6fd812dd195ca4e690424a965d3825a37042ede369f153e903cfa8107c730be7c1ec044e3f3209182d9ff3bcde02997794799d9ca8ea79ec68384e680ae812298c6d4a63f8cc2677542026b93a573dde89e3594bbbbff58ce220bdf4a172a7430360824cd3e712fad825e9b2a59a58ef0ba4414d2aed18b57efa12517ffc7255e2184fa13ea5544c2c664d064891f9ece795fab40b162d39f11261d7184cdfa8fc922eeaba952112bff8a507e0156e2ae0387e56a237aceb442c372410bec88c9d48be3063f5f14f3a99868f4cada1e34fc4de6059dcd9ff795bda5f1348c855c1a564b86deab18094b424bd8206a682203e309718e4bb0da91ec5d664b398a1cf42e33fa42caaa957e0bf31c99b9fbac4f3035e8f8f41e2b4baf5330f9d67534af290b731c2695209eb18aea6f43d320caf47255fee9f99109ebe562e7c7324ac37d9fe534ac8cf667d2029eb7bd1c72b27590a42426491d87900eb9a8ace2fcc702c19f9f11146e4af5f02dea1cf40136d689525fd38d5a6163eb69d1694f8a944f5e6279c34998155c37b81a4a93eb3da9e9507ad55e29dc1bc4f5a55e4778ba736b44f39edcb988d1f059c4d89419b895645f76aed85ee6fd53de9263b4df47350813b63881671d1430107289a305438dc1be3ea8133d7f2d6176c9d8b0cc22af526d4c3d2e608b35b31742b73145107681c5f8141203b340f6726f9c4f546d621b3d254db62e82d0a7df8a11e6c0b87b3ce865eefb49732c4f1f9f11fa6f4f2e5b71cd999615e9a5f14113d8803303e3461bf1e5211aed22836e46ac399b4a592d27b9820c4029af581e1b002dcf2a3dd4dd7725a0913fb60eb048f0d1d1ddb6faa811d4dd7d20f48bc69ae84ccc08c2218336c0cc2123a730371a6c5549a1a951d89758fe2d4b8c169312bc501bd162f59948191afee776f2f044dfac6eaed398dfa13d22cfda8291d9d6a75c489c3d464b030e0a8ca26ea5f0f3e2bfe55bf9a071bf8e99e8e708b900fa79f4b47d57ceebb90cb9d23de17e295336765593705b55e27faf12dab1278cf7ea2e5a7fee0ce9a66fca0eeb90ab4ea1bce03e2448dd06edb1e2b7aaf576a4fac5d0b3d36203d00b1a92416b088dcb88bc4d989fa49e3741238d0e57db09c3aa3a0e1bc2ea97420aa014f92ca2b95fccf3a082ef3f6acfd5cdc777e915c35979d8b28808b4064223328bbb67519ad93f6988058688dbd7e334b29b5a98b68fbc0b50f686ea091c6858611b544d86c52fa676ecdd126156be852f16cfa648e22c2b6fcb512d5f23890def55b8f4947ac8a77be05785e5d9bb856a52b27aba39742f4647fbd034b3733ead7cfd348278b500067be51c03b14174f2b9622b3b611e6b3eeaf1abd7ed1d521a0a96a9355569bcb872a3112c6c392fd567f420738d59e4a463f085cdd1c6f0226c179793a01086e4e105b814f9de5395f1eff0ad65f2453b7f2d1c3f57b32dc4e4fb159aa49f87e724e936a39b76e20e6ab746d0859cadffb59cded6c940195a7028e0f5aac1a1e1a38cb24d7ba16e2bf111315711a2ee752665550423ab574c5fa99d03ea0c7091588ec049919ab71c973a21cb709ec57dbe2a844a95f9a987f8e6e83c2867cf296a89cd07a96c9448ca842ae24b5e4dc871869154cab48e09bc78a0903e99c52ea1b9e0ee440100f2231c3505f34fc66eb1122d970aa4fde967486b2f199403810f2b35e9e59a127516b9607dc66bd739121c0768441fb949ce2f2b37aa46343a85a30267e6fbd6e82a067596ddb5ba6c090c6ab6f07371ebfd7058a9e7fb621c797f68e6d5a33740eacf542f5801d44558bdfe269c721f7111df95451dac04b9f9a41b6c2ff1e6f5a8321ecf7e795677c7313208f7670204784fc94a6e5e7cd84894792c98e052c937ed7c0c02e5929874d45d2ddeb43d39bb049264580b3eeaa9759bbd1ad78d474234a4b4e2d0ffef50337fa451902cca86b2278b4c45c1b196df0775345e51b31643b4d40e69e23f56c7db392fcc397eadf89265c30aff14bf615c18eecb410d7a19858ea5f5a8320cbb542ad265fc131856e7211e72f1ebe83e63eda2e40597eae9210b63167d49d6c95546cb381e3ae38db77003878e2a61e4adc9100746a6f5955d94977eb5a784195f077629495723a9122c765110f7e093b266d0cbedd8861e1bf1fdcde67f3eccc0787fd8488a943a5f9779ce85cf38e2af4561d6794e90e30190b2d22489a972037ae1531eba6cedbcf2c778b605db94d0f96caa7335f6bd58ca82000988da93831ef1229e0830b4f9fd6582830cd09219ee47c96a925dd5898d8dc25cdeb386abe126ae58feae912207f58af140a101168cd2b4f6dcef02abdccb4d40e7949a6ab7ab7ce23cb3ee83856e3b3c1d3e665c93640f04d9d304111e78307bd5bff922226141a10c2d2348a53cc30c13d3945508948e6504cd59a0b3a77a47704584f08c684804173ab8968dc7fc68469c76c12913a87621dc1decea302d93a3c8523b6bd21b20c1acdbf2c7170d8407ef9712ee6bda1c5b172fa788f718a1fc44fd209f6212a8ac9424675fc607d69bd70bd3f2fc7f9b995297a2df244d3d4db1135c268335c587585b0af74ee844d838177a4d9f7f76fb0c8cd99dcd1bdfcc6356889747cffd4e1762001f3f54aaf0615b5863179cbc0bc600536c2ada14fb236624edc543f7a9873ac8d212181213233c674c177542897437d71a9c2efee9fdace44446c37681f53827643092fcdee1ac0c654d452a315fc99b9cb0c8de62e8f4f9d8f21f1648dffc37dda19e7e73f7ce022ae6fd14e744d9b63ccf15382d66047091f5dc3d31466d8d8e7eaa0a8cc42325f3c16f109655a3980ffdc352c842e3ffc1a45726e02f716998e8c9f61d52e0abf4b17c6f2da256ddf5888a1d48f21c30b8f1a861fa97b183c524ba3909f7d70660e1123309310089d659307dcdccabb4133c549cb57942bca49cf4e905e664b4bb0de4c4d0e65a5fff38ff652bb970cb2cd8ff57f7af9f9c89a904c94bedbbdeac5606afe7f7c234eeed6c9b842b6254c6db785b95214dcd4606929e3d46afce5bb140ccd662d19b8aa4aa1842a399d627316c911999bb608acc051797fd9488573a6aa985185aafd69df65020b56b5f56f4d91f0ad2e8976edfe5725639f57b4d2cd5f0665fb4e9f33e742e74e2ec86fe6767dc152924d6d168967a6b9f63b1860da244520182b50ab356526274d6c1fce787207d12f0e6acab4177484f1548ac6eeceda29e29d40ae20f8f3771ab7c1fcca1766ac152d28d7a60ce7b6082734c214a35165bf09dee6a0d58c6039f752226fb03dff6c511ab964b3a33113ea1e4a39a313a149c3fd3ecc22843399fe8ecd8f6fc701cc3f18605a4ff29adef522800e75e6c51384519564c8be9e14da1d4e60f1c909c1f473528120c9af4cda713e832cf70d571017a52b7df22d501b339bfd69ebcd31f97b6931141d99c567dd852319547626eee474d56822031594e4915793856133eb873b704a16dec870ee8965f1a725aaf9479700ee3511d2493a8b4328e2bd7183f88880707d17798c7bd9ce0161d79d61a29ed9311aafb7445242197eb00276d85cfa8e9bdc914c27ccd223e607c0f031da45982e86131227c8aabe3e5cad36f7c80767f3b74c1e927cb6426572400d997a52efc06a93de8137338cbfed3828c371d433023dfb8d5b5195f016c2015cd014b0d716606ec425c46e704a00df71afae7f3cd630853fb795048d11fb206d230174fba29995cc480645fbb7a5c39733b6446c73d06e7a77621b3e829f6024df50f6dd0b6d1326f8fd4dfdc899a99bbddd66f282273d93f251eb86da53e5640dc7c126642a8993426188e926a12dc072befac8c9274c89d8859954703d329147d64a25ed0dd7963516f45af375a1f71ae0c5722efcbe0244b6cacf1614b12bfd77a125639ebcc9e4b9b218beb3c6e07ce96a8a506afb2378acd509cb60367e14bb5d6dd1a8897fbe15b9a48d0a21531f503d99264804cc7cdccb2593aa6d3888681684d4f5d0f38b76727b4ee6892f04f62fc02a7df2bf19f8646a0fc8980179f5acf2019a72cdde4a3c1baf0c597cb0d814995b79218e9b50787417d6fee4dd8cf0cb155ceb8d2406b9df6c62e0580c4d06a6a2729a657ae38c66b43bc7a44864c6e5fb43ca87d304d59fb66053dc341129bb454e8ed83040b48a060d918fdb0a19b2c3c6d5f85ad6f9a846de873fe4b7045f67b547e12bbb8a68f4023fb30d73ecfe54586932d87be29b99685acb054ac55e8ef73ad19865cca344803cb1a77532a8c785a4dafaa82fdc39a22558a776aa689503443f22e8b8e181d8bf5f297618fcb43dd54545be3033199aaf0a3855b9b6341b1c6c061c1789f4f43fc1e44af37f288b3199ff038ac30d5e4ecbbbd1ea081e9a6c6fd4821da653173077888ef78f35116114e706fcef04e8457d5f2c948e002cdcf79e98cde91b9d7eb00108889df0e1d293931d9032d9adc01b40f0d5be73720f72ad69598cf230551645786652b7bbf7ed2cb58139909558069cfd27809124f602efbeae39d2c87009353a197807de77e98891818be3662a01ac60f2d05e951d44fcd8f3a571e351775d8b9b1b6b6bf02bc6cf1c226bf3925f7c0863682a8147e3f5448f2cc8c360b14fb959fcee3a45853993dfe2c59497887cea772a7d049ffb59aa8f814ec132abdd0c0f81225df849fd2dd1e3dccefa2441d95c8623575e98c634c90bfd2a62ccc0c73fb34e44a3151d860cc32a2f9ebb751c923af3a0d7fbb42a4bdcbb92e1eaeccf9c42779d083fff4371a8217947baee793404ced91025d92b3dfab1314352dac70458dd4e8497c8c97ecfac955dfe5b927a53882040debbc56ced8af546c4382eeb3f6a76b818b1c69c6c208ca0af6d5a48c4800fcf5859ce39807043bed114092ac1a0ed9c745832e1b5095d348766163cf2537257c099a71a6ea68171ae335590b20639ceb7eea9aeb2032da4370ebc5b2798bd1798281a0f4ba03fcf213b6de57ed4bca4cb6610ccae84c815705cb1de090691451d51b854cf895c24e7ad0061cd773488308baa5c13867fa5aaf9976316ebcdc6c9bda4348bce3c64b606dcd883140efd6c06a9e727095400ef388bd9a13e085dd13cd2b2ca136c91cead1c9986e99c0b989420f9e073c55d02e9665ba3538a14b6496b751b9ca68dc637e17ca084202ff78c9809b944246b2741f1af7b5aa665ede855f817b9f1dc5db7d5f97df508b47f37dce1ff666325a2db3e78b2b0f7e9e1d247373ae2f06b0f0c0cae597926957437a673c5797415eec8b9986a9bd0a6bfc93b0f920d4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cbcfea95816eedbf163e23f7de09d842"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
