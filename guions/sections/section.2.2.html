<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Pàgina encriptada</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Pàgina encriptada</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Contrasenya"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Recorda'm
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DESENCRIPTEU" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Contrasenya incorrecta",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93f129e51e0f8e6861f9850726ef2198778b3d2e9134ba1059c39c31f7f7051f4398ac7f859da99ef76457d189b8683c39ecd1ae4097b751aa2eaf299dac4d4ee3a4f761d86c10382492e75b2146eecc44abbbb3bfb7650f8a07608df4dc147b2e00fb66ff11890e099a3df655fa1ba647c7dada61a98277dc5b2fe92a73eadb807816ee992af63244dc2c3b49debab935210d691ce725e5c73febc32435f3027387931017211d6d5aa1ece8d9ddce71ef99e53004113eedfcf2500e0cd3b7f214e1e5be47bc00b9b6ab59c2ff598fa71505d8cd3772fc916e893baa3e7c48c5068aceeb75ce654183b4a5e79c550b2c8df22b1ce6847bbd98a044f1e2c4d204de388f82d1c0e7207d711bdfa75ff23896dcb6c6c89b69b339348b87235c7b4c8fe47425ffa9108682a8a9b207f3eeba43435b2872d26a35a2f134c8ead1ed60eb5d968b00d1e679f569cf07f3f9252306d91ca87a16a8b28631ef5e5a19113d8b25e249efdeec6d946c3666b2cc9cb2ea63937dd7ac179d7045f55679f450aa57e72e1b6571a7971fb2712de5d181d9f469adfd667ad606b4282743db4cef45858894b3f8f6c8bc08515302dc7b50d39a41f9ae4ad19f3a5aea0ee5a39f8491177173eda105c6b14931fb2d192921f0d03a5259f2067082b97b1ff4ba131c4e6d376146286d5577a0053f831fc4f0b099f5b2c2cf87a515d4d1ada484d01eac548ab20b9ff5a608c1e78dea89e8b10028e77145f1748872a8235af652a1c18d34ded4f263ee919b1dd2de4bec2e2d1b9c5fa72137515e0b319fe6396bf33ea5e18be3aa2dcad5e2eb1f29e1305358a0ecddaca151ec2fe3f75c5a8919dc0535496895bae3e24a5df53d160a8b9d6aebc801b83cd8b966f9c7336e5ac4958923fdb9328325493a4a414f5c669acf431460785ed23f54de329ca1bd0aabf5102951ce4fa0b0679498ff8d1a8afb2bab4d3fa3a11749630e300423fc6f3ecb3a1aeb34263c1fdebbdfcc9e80641c9400f8da7adf5a979eddf641cdf41cf4599570c86761996cd7326b0d0bea50a80f12689ecec1d0f0a466c96d2005c833170e764a9b48a580b93a0401d05cff81016230fd5a6a37f0ec264d0a767745fc718c68d9dccb69af2c1e038bc448dab9fd6f23c84e6d3ca70700ca1b9db640aa81adf191a4ef1ad4325c2b294414e340bc2502f8016b969b50ac3351bec0be45d3fe50ca62a66f18a2d8f744d520945d79a1549df59650e8280c3c24070de1ab163573d7e96c1dde49d5eca8d21f519440cd079baf8e4df4c1bc048cee30182591770ad393d17532f2c7948f6afdb633d84861ddb7059105c47edd0f43859e854575c517f33b317ffa68a90b76bf96b9bcf337bc0f6a84634f8b51efa5065df4f16b18bd94b787717edaaa46de1cc51412cd5e72373422a20b9794e1718cd65d32a0e3548e606b08fb64597a1ada27dce715a307fe5cf90df4624a9ec1c6ee371407a4181ef1eae3b2daeed9a2c7a39093c692bb966db0c2a809da3ac51640c44850b68a43d428ebd1640403e92475f905b4916a6f0fc4c254a54363af9614fbf7d92d131b3c276be55f8bfd89806c44d409b44a2a0bd04b449a82f78464f2e05ec92bfd2c72c459b2586e947220d1f7ac1d7e7d958575e17d15e674e19e95da083d3cb82058826085161092e7d83de684f500d674b031e60df1226655531a4cc641308c036a985b19ddb1acefce4cda41b25ed50d0616d81e826394dc01cfb0b653387adda33cd8fe3ef5f23d9946b89459443150098865da1f9e6b6750c93e59eab47f9ea3240507cc9d41e731d3c6f553b3a34f24f4811c8151b4fbf9549e57fdba6a6230b8986d0e0aca7925d93a0d4697b91530a83f7b993a4d63df16efe5a19ddf94c84c9348e114c53d6e211288668cdc951d22a5e479ac597aadf60c18001bedfc8efb51d52d2c9288dff08ea0c5e47922535b85cceffbb1d5d27c9a7ca45e26d3021e54b79e2138bb6b2fdb60bb13eae2f7ce8acb6364d5a99e5cbf46615331e63f7bd7131a38135eb47afd4dfd9918c9e73331db232621161b6de4a3e3b3601da1e5245d50188036da18a877799d433ef48d287f02fe6e5f68e34b224b878c4d7ad1e046c27bb49e131d3838a06b881e8063912b1b696db8ca29f96d5829749395cba3f3e6cc8c7c63d50ec099e777080755bf9222a8b625d89bcd205e111581cc42eb17ce0879a6058d70ceed357dcff5c15ea8b0d3ae5138f04956161d60f2aef7a497a638e8a2566d0abf1d409e1d559ae042e76bf19762f3eb2e8ed1ff1267e525c4693224f87e4e8005c1cce89316eba98d5eb94ce772cf9efc0eb1659049ccbd7da7c078ce4560128cc95c8ea16685874d50380e5e7eef3e6d48f42de00bf603aad2b380f9cfa8e1eb8456c9882ae4e16e72dd7327a6de65d92826d2a46ee67833061c8f92f431e3a57fa3e463875c64983533a54e9ad3299b7507de1a8191d752c98f4f13f7b96f70574fa5489a9b06d368e03e8122279f0ff12aa725ae0ff78c15ae46eeee16cc9c48ba1ae7e11844078b02c1db035385d9abf64369f231a5a99c3bca478d531dee74ffc1a7dc91d3577b96a2f490989ad4c88c127a93e6b1a88835ce4c1460ce09a48d3ca27d296e338297f0b2c034fb544fe2be3b8bfef9057b673543d32fa468f0c63e2f6b45c2ed55b798f4dd3c7d0d9987a8ccf535a0f5faf20e0d859333b635995b5d6c5eca8fa57a4f5300c62c2df2cf6a015898fa22e847a155385b8ce1a77f5fb9ba5d233afd305502af6e39f3104f21dcab2ed4fa089203a17f1c5cfd434e37c1a5fa68c5951fc27b0b5b690d4532b977fd80c9eab0efcc1f83fd23dfe197edce399a49bf911e65c911c7adac9d0d673ffce7c345b5c126702c5bf5259ef8724e34f7f170d4055dbe59b87fa933f247156caeff87c3ed628f4ce626c7eaf05a9d6878f244dc43965a4662e9b37e33faa8c8c727e04a12f54f8740e9ee093b370dfce52e7f56972473ba8d1a9cbb4612dc92051e29cefdfda98624d722e3218936ce711a1e8080d68002151f67df2686f7401c4950a3995953671b4dc91ea32998ba656b80ebb0809f7e383c7464f09d2ae81012559172a480d7d38d7a834037da56daa7f13d4b64a8a1027ac1ca3c2182d494c7f0b20546d22e9573af496d1cb6e2e44cdbcab56334679c0873cc31739d0b0298c3f45aad3707098763924a7ec7fb80cdd931647b0b029e9b42a9df4d54155568aa59aab192d9abf77977b34fa40a3b7ab865562fc8415da59fe4891f3486889075dc0a183a971f6a243e6f9ecf38f3c21ea508a131e6a633f25928037096d5aa9226757c568dcd01eb27c90a1a777093292a9c1dd3d4fec7d081caf7af410ec5ebeae571e95f29cfe8949613498ad6d629bde12eea53d1b5669b2073fb45b4fd328317d56bb213ae0211fafaef650cd670005fa021cc43f0f35c3d1d07eba91b783631d27121efe4bd27f6f68c240c48930db6836fb73d05bc67455531e6a42e639299ef337cf6e88f3aadd76090def6fc3f86b4b80d7324bbbac7a15ff61a579967a163fd499367de0979b9200f410232f74c0b6cfe651e2b434d00f83850aa2da410cdd8a091f56d2e9c2d36f1992934bf7eb69ff15730f589fa58276241aceca2e10943d39784e287c73ee8a5ce70283d4cc285367c6fc801da8f0e7856b47e77de77bc605f232ab84878859c747c44618b65a02c7493ddb0dea4a2a0dc66a4c88d9d6537c39331f3d2e9b961c3ca4ad58dae4da39a337f0e6cfb57b1b9b8f41317f4611e06bb1383529b46dcb270d8c140c94289d072adfadb192d4e0f015b365f829a7456251190576c8f83a6b53b7277dd96435a69700d5c37c91ab054b724ccf2f01bb229ecb18ba212c355f541a91a90f2d049b29de4b5142f3c07a8bf64e6b27dcefedd3a3d5378ae2feddd01312aa480e82dec2cd1b5e537f1db8783f241ca3333e1219587390b769d0e81eb9e7b4276ad1df1647bdb719d7cf3fd061ab5d0bf0ad96e45d4dea9872602d9b1fc39c3059d3a3224a9a4c43cf68e018db084a92c215287e5a659fd143370d37699da470fe531da58e110f711a1dfcdc09a29619fa6d6c2fabe1aa9481bf3870f080119027f27922327c2da2ef782c9e5b12ee0bcd8fce2eb4ad93125ee02c54e085b5b9899ef60bc8ffe69a9d5f8e2064f429c59e8acc7625e87297a405efb2da33aa36b052a65791ae229b9df3b4ad3c7ff50ba2b90c6257d1692b5cf0ca09acf2ea1148a15aa4d4e88f0f329c8892c192c8603cb493ee9d4184284ae556a36f9db0b9aa45f542b684d0f1bfaffe924a10d9e7b1e274dc3661f28493a111fe9394a7caf045a72dcdf9df4afe1984effa26cf641175cc1e3903335b08ffd3b0b26ae7ae38aefa8e660fa23ebb2aebc30bc9a7ab696926fc27348bfe8309fa92e8c442c92047f4e985449dea25dd2918f714d4d94d4af007fc5b4dc2bcc753f5c6c9eeb4e0c090f6005605a3e78e155406b1a0ca104679fd968b517bac85a9cf56dcc70aec25ea8978d71da0a4750845d91c33447f270e48c093fe209007865588ea842b3fdf8b8cfca9a88891fbf5d5315909b0911b4dc272fcfccdabfdd6cd3198f716ceb224a39ed8dfd6397c5546c363f799aba0589d3a07099b777df28ccfd5cf78fce0a99ad009b30dee2be739f31afd31914d144143fc5f40bb6042fd5120730b45fc2a70bea3a4bc4632bcaccc3d4f6f1e76ff09a41b8576454e434b6aef0c7411aa23419f2947d53231375ff4481d5cd40cc1a0a2b30ba2ce2d7cde27b85fcf067c1b46bfeb19c09a62a4882b9248076c4d502b23ce47c14f0277a5773cf4cbb36c4bb59ef89dd22667ece6ce8eaa22ba3ea66e5e8c1555ee4879f4a309ec9911e69dd06b60963f154294fce5a0853c74dfb441ea59f279d090a2a1efd483ca89816872f7f8561405b562638541441fa7b43996dee78bf12a12400dd27ad45bda3c090a967042da1fda405405ab302a8f9ca25f1893bf112134d388b9fba2c3a38e7c917ac8ab5d21ff05df32ce34af0413f6d4ccaad5216b548c1a66df75b58dc3ddbae94d01aee047e60f6bff5af8dab2dc351960d40109a16faf753203836999b2f499a0cdf27000d3daa86eb7c0ee898c05f33d1c7c34ff44616fafcd5aaba3a3e856953522197f0d27aa356fcb016583647c8cb7cf3eec11514dfac1a2e013b82d3f2235cd1bd5d04145f214694737867ac8a4b45208cf1049010e7072631475dc0d4369800e9f1ac5969350aa378d298d57456b7848686e2497f2cb04ebb4caa3271ade5bd192cfd441e48c4f8e70c41c3572d3f0a8c8da70b3a7db5edfbea6d39a90b3dcb3b92c570083ae78602b2dba381955159c956ccd550c640cfea97724eae6b6b66586248ec8cdc01073f4552ae695685594c03db0821289da183b22e66fa5d86759981ab7095921692200fe39cd9b3c43f7c6f6bce6724f8aac6a2299a5720c89f26cfd6961240c528e3d3bc5e528a0868b82d7d0ad27bf0e4537e992fce5f47698d204fb4a7aeac1faf7794d19f56ca2f8c1ba63638a577ff8d1fdb7348a121b4ae35af9c1d0e0168ed0ce2c6ab26a02c9f06e4d7f45feb3ee7a736746fc0100c08bcf931b12217ed12c7e7c01c6952b1d04290e46003c14fc3229578390bc4bb34f52410f95216afecd15cb3723b951bc10b5e8153a82b583ad8659d258a7598fb8358a31a1506026f95e72734c75e8497c0da4bac74b71bfe27901446f5a6172e5659358faac93da646c47bc09875941955891a619f15861635457339cc6142f1fffa4f776e649f76f4ed6beb047fc294c8c8410fb5b449a602751454f218ef9d5385f3aa66c344c6a2625270f4129a5762def7bd8e13e41934b178dab452b713ebbda5e2f5d63cda6879afe21b86a8c26564b0ca7156af5c85deddfb0a0504e2ca59c55dba505c16e884860d0430fe665f916b161ae27dfaab04bc64fa570b464681e8efb104f199327a88f1219b4393020be49b746f131d45a0ec200a86660a7b03b5a6763c7eb9d473087bfe281cd2704c1ec991f001eb9d55dbd14fedce7ff2bbb2a1c20af3b68d44dfd2eb8f6d238a821c5d2422bffef79a8a19f54fc1e62f1ac4d0d5ddc13c530aac88aace2fd09179d3606cc1c99899a3e3f198a90a79bdf9f3ad42c776964e6963f701a36bc7b8f70e50f3d22d69d0267eb6c3bb3b970f483684c8631d6cec13d59566aac2beb73b044326c45ef80b7b3065e7800760a0f2b82ae706b6dd0663ca6581f9f8413f0e18ebf2623fdd97c60c12e304200d943259e5e14fab0cf1181be3c55097328e3c96cd41b3cafe8837ac76be59e20d66eef108df170129d9be028b6cb9e6d4bcbf5c002b468326659581a574503e0c29fd72f4930b05abb604aefee6b3e059bed428e0de66f0502cc6c6116e6eeaf3a7f26073b36045c29ed9df9382bb8e98bd8851c719295d191a19f84c60dc69bf8922957e9fd6c5a02ef254ae85a4c58c8aa51901b6622ecb0c918d40227097b862732d6aba373a817f49ade26996ebcf83717ecdc1c14c3e34753ca90fd33f5fe548eda3aecda53dd7028962c3a18a07e11f3ecc1c25712b6152be1435b27420c518b9156f287b16380fb92b98ba4a6c43a1aaa63223392ea3d9b024eabd3162f6b7995cce17aa5d2d1eb2771aa12efca2c7757d771db89e6af7b1b8484d48b3d8e085f5331e9f41a89ff11ff8e8d6b74c2e4d8c9ef78300ee8cce39e55f4e7ede525f170c984edda9efb81c064a890a79df616b3081d23eed275119ac93ff5029f26c64338df1770a6b71536853455acd58e07b489d48d7d540ae0009393b1265084e65419a3a565c068e6aaf4af7b26d8454731a67b9d9b01ec65a407582ec2db6e006644d65506d42e7f0714fcf2d0b867693b2612fcdcc4db52fcdcbe19919de2209ee90acd3eb5b9de80ffa87c468948fc977c5e9368590f7099679ca6208a1d1b15f2970bf35aa1dacd72cdb9362838517bbfd41bfb3197ce55d9ba20a82ef5f3ea3a52e9cdcca4ae0c2de1c6de59bd7dd845be562586e652e979bbabe3b4826cfcd72b1ff71b6e0d14e64e88225bb1f9bb33bc4f6baf83cf0582454a2b795fb9f05cc275f4e460366d8d7268afc2c47e6c8c49c6b131c6f5e1e81ccf8023e2f61d7a71e9711db7b3818cd668f3e63b154d6ed247c1af5dfdb3f1e344b36f3f426a845bd0bd1dfc12ad17bce39630c459a14f94272ce2f036e0e3a7e68d7d117c68b0f11b8acb54babc4cff8873c0ded051d2608a63a5a72ee128389d53410d15a3d50dbd7c3f7de0c0f623a9f31fe6e6d07e76b86b8724aaf023e36f9ac255dbe50e96f1a083a3a90aceea3beafecbab42916983ec87ffc63a8841cf49ddb0fcee0fe3ed628ec614a27029eaab74ff146a59bd3ad520cd24725d2063aca53e8ac7824499117f8f113d7b6e98dc072edb571e543c3fa90d6131461bb156fc8d1705d28c7efd63daee1b7e5447a36e8aa3316025eb397b00cb88bd05e86791f3e1970ccca1103cf0eb4a69095b438baf63082cddb114b125eae2f57c0cf6c4a937196580455ad7b7b29d3e87ce0712761fca98b9bbdc53b9c3517c073dfa0e2e868435a0657a05de01eac77fc0e68a0ca811f1e8620f789806182b76dd50dc0340ce5e2073a0c511fb3c04d2516a3c8503e6dcb1fbcc552ac7a89c112a052d1fb7a965a04ee0565b10bc2cc40157b9c08a90f38e14200f7e567bae9da6c7e72ad7d134d5f126bc9213e9f9cf15ba10ca06e4403091c83aba471d1abcc3e43585444c6e8a87b2b3772b9a430ce177094610649cb1bb631a3db403e2553c2a96011419ca805889ad8b8c9c20ced8bb5ef607ae151e53cc9c4074cbe6d876eebd92bc0fe1c074d097281440450f258742da890af6a6379b0171726d3a78c6d85425e7aa6a4cf6220cc3742b4cd2f0525f40f64f503bd80742317537c34d1a62cad04db3164055ed94013f3be22308eb528d54c3a5fdcf0f036d485902ee991610a0e0832f67ea8a5b9613fcda087724ded3e9a51ed41621a5758696853e2e388e188755f595734b2be0675f3a7e130330ff2bc99f6bd31a3a1ed8f128a004d12a0282c611550646a6cacfc49898390cdbe4a68d7ca767fdbaedc594e2d2b814622c709f601949745657eda92ecbd4bae6703554cdb827355e001c9709601c90829f44555912d29820b696dca81b7b5aab9c1786be54bb53136fbb857e5d7a537555126afe53fa3d036b2908a54974ed2807555caad60bf2e9e5e8728388d049ab1da68abff49f80deffc20c58b7aa782e8bb5641e6adabd5114c7e108e4c5ec05a091a3607742209bb6e8effefded3464a87e4a5fe1e30e2850830275161d9c7bf40990c88944751530c9262dc4e71409e64b3619bc1ecdfafb36786fae1f64d0d8f23d45878856e6676e8c6c0e87ad2f539006137df5cd3250a5c27070996c76e7a58fd7b3ec65d4a493ee6c9e398d61d1c7b09152d09c4bb57c602293b7624f707cae3abe11099e873e01b8841d73262dd9d6079d88ea1300208b96461de4845c61932b13d65dfc2cd02f5b15bf453177ba048395a317ccda6963643046d29b733b511533d2210c6596727cbf217363c8f7deec37265c507f810129387c715a29b6501bc9030a367370979d9eeb59f663272f892d180888945560da2ca2df8b32f1ed935f1b4713c45a550ae3334aafe4bcf9370b4c5c12fe8c02d788d36a2e0917cbadf024a170c16f68e6e1f76b1bbdf261b1529c7bc10945385d1be61d88938f2ef1112248111ccf749ba1e3ac7ef2a5c4680c47cdc202b81ac047f3d5bd6219e782b9aa6872a7e475ac7a0b73b6ab0d1685674dc8305404e9f9d1b26748a66d294a8e68e62daa50403de3f3d7e59c2bbc0b27a54b970613f445b4251e80d157d0312ed52e6b09a8ebde5fe4e0598fa31c0db64c6b181595ea492202c96a6e2e01945ccda1be4cbb0276151716919de023789bffccd4acc965c822a00fc51dd7f296a0b3ecd959a6c94203c6238e288b0f1bfd5ec32d47ca43d026a7c5eccf36139472790c5035a22eb458d1f2981200f06776aefe1deb52888ed99520994fbc599eba6dbbc2c07ae3426157d21d538748a32d405aeee1f220fde936d896491a24f82f8f4fbe32bb7b9861674b229fd970c78d42487e71ab9e73e4912e2f7ddbc813f048c1fbcc0c57473e4bde08b26640d649ea289b8d52198b6c7bcc9b215b263cc26efb5f7298bc419c1afb0e01483b74e50bd89eccbdc8fca787fc13f5f2afac138795153579c05d8a961051b0927c79e8c5d1b35f407b532cfde7f729a6b4bf8c768ed25eb42bb602f2d7f915b4df0b681f35b9e39d1aa48c724ed77d2a58d4605e83339166475916324c5940c1ff9f32193e5241fc3b2f0c173e292694c864b8e62a0aa391f9fb1bc26213f291384bea0a77b1ab2733784cac2d06da45bdfc22a39dcf51beb2e10f6730edd4b95cf1d42cd40f4a4d0c6c08d60a4f5db1c704755ed5c94c25f86ebb3ef55a12d000d1a529d4386bba946f19c293ab1aa1b63d3a72bb41f845ac8d200111da0f9e544d1532d53f62e909a9e0c6e1f941bcb6585ff175b2abd0c8029dfc0dcaf03ee2a494f47d52cc5b6799e2fd61115c0071396a436a479a6b280d98d505c6f55f511385d8d59e2be5308568a6284cba3be3f40954e73673b58ce8f92fbb2844b6c838069c295d93aef3415e7e55e9654143b85b2626f255ea51ac368a26c873620d3db4f73bdbe1fc77980d5956962cdcf273de7ecae4de30440e0f53aaab135d8ed59f65c631a898e8296a330c83a72689fc3bd6830aefecd45bff5ef51c991284fcf4a413d6e1fc765e7cd694a122804d3f2a417dd94369c1187441d5f62292afd7e4986a94d53e80eb1eb6bd55acfed2119fc133ad26e118fb9fc2f8b9ae54f132edaedc399365c11307fa3225cb6f0edc9c8bb0f9fd9d3398b3a352e4bb7c38ec67f9f734981f851b4eee829954737e3bb939acebcdc4d09cee0ad6d2aabd80800d9fbf6c54c65be9013099b44d5e85abc4bb5e28c55c69202bd9cd2f7a6f60cefddd660851ea4b4bf1778d8eb6111cc1748cc91cbf4c1118b2b7b3d14de6b884b789bac6d726ed97bc53295e71a056a56441f72c8c6b840065482b084382b335cece1241408229ffa121238cadcb4fef957e93062556afcdad200a615c339e13853ca0add94026996f14b02db69d0468a859e9ef4806093f8c2e76e9758a92dcaeb571a35add370ed683c80c4bf83f39df1f6441d39eac3b2f5529e35294f5c1e0c7287c2199a845f0570c78ac01255efee85c04f87538f76e63171d65fb8230cbc4389c2ecdb7a3012e5936ab90d5614797e1e0a3df4d6f138619658c8714793ebfff1f246345ae8ad9a13bfe30deab1e47b672bff2093302a85e75184482cac30deebad632a4305149931b1e97d822a872ab96928bc4251bd4147e8acc4cfee7b2e54ef623771ae87649d2c51aa4af2dc3e7d9abb379b19a2eba941938a14fbc318c2831478b241a373b0914ec206d10b501ac2f4c498b88537334f142240a5a9fc83426455d3af1db5741576d51847a337d9fae6375ce47434d55e3949aae55260467571c2636a10305ea7a4f01e5e93898dfcde2899851847db13f2ac104f218c68f133c877262472c5d4c0a84875c94e5164c2dd137c7136e64eff9bcfcab05da81bf624fb8b8a3512d972a2c2d029e78eb81ea0b5d55b3c77bcc6d5fc30e6a02f1ad88c4a0aad610f8d6e9867d62efa27419ffaec1d207cbac02f07cca4014dd1cd2ddda6b50bd375393397ff031a2de26e0a280ea2956e89db3cc8145e354ba3ecd39aea08d2541448ebc113ed31932050224d8b1c04fc59ad31f5e82cc2a888fffbaa5b554d4583b76b8a44311f33ac7521f7c3c1609e81eb23b3c5cba64ec53c41287b63f093f1fb5b71824ced942738d78e9c854b8b4276c2db000bc51a8e12d50871a207180e520f363dd18a6b82d5dcbdaa8ed0905f26c32f6777db7cdbc1ca5bb6e1341032e61d06ace86efef26c5d798fc7ba59d9c0a99fbf252ce89cafec166c629780f2dc974b48a294b319499ebaf380ff3d7c711c9614bba2b2cf040f81ec0f63e563a02f91d59f23248968faf93fb7a29a7c4c648e0cfe03b1cade753f581e64e204337f65e8237a9648add2cc9ca7050bd951f51fb4c30dabd44842b7c87082e068cbe76037b62b1688bec4475b12a488fb6ca1eef210563bf70ed4bafadf50f65536ecd4638eef63edaafd03b20698dcf95a1037dd979c8d8c0b9974253f7399eb90825eae0858876766a5ae54c83977ab8b20ce57ec150b4d131e410cabbb41979ee47d0debbc2d0d2c8f21569548cede38b62aa78228ef77d90961bb741991a45e82af8a75719e3712e7d258ead5dc91aff3b0fd51ebd551229b9d9e7601e3db2ba725dd7ada2e94922b9dbaae192afa64198cd9d0c0e9212417e63e1bfc7cdbddcf68253b2a51f061b0f7b127f7e25ab5a1fd5bdfc704bc9a475dc73360646876a140b4363ecb8a71ef174d3c2645965ce6d49faadf18ccecfcb7109a85f089d1e9ad136a736df64a94efa4da9415e585870382d7bea1dece80f03384e1402cecb34ff83257e1d7ab2a8c9f35763bc047f07163cdb5272ae4da5ddd06858918559decc58452814395a28441d7f32f35d4ea83aa27f9799b8c2439ff148d46c3ad9d3048a74ece9cbde8342f31dd68c5b2ef2e62fe0824ae6458241e92a1f3204b17cf355dc68f4d734cacb22b3489b175c33005a0d0303bd4b835ee0e380e6d48470622769b914a70406c7f6fdcba6fb0ea8d285dfbb45020996e60ba8504ef63d13d711a961da1ef4494780d85fc2049dcf6859efd6be8e6540537f46a4fc0385fede1c6b089023960879b1216ccf9f9c77d5cb119d85ac22cdadfd885d17fd629889b8338b4488025f7340d581a29e899001b3fc06921b32a047b96b4091469f0f77a777c35d4a683bde3d9130bc0b58811fcac1d9de78cf4e6ae758559293f293a27cce1e08c5b156991e4110dbce182c44002bc429088b098e4e56a6ba82ebe04de2beef557c6f1bd708ba82d0ad5fc8cc7ce500d129b153d26366040212a99af78b043054297721c006dd0696ef055aa59a159aae396b93d8b80a6470951e021bb71fb9751c5ac304b72e3634c7ea049644aabfedd0582de9b72ea1900a82a8e407b3f98b949f08c53e36837e38bf346f3f60214e5032d1707090ddbf772297d1e3c7ee13a447d2b92ea3771b064119d2edc5d6670871746a2149b47dd053a6082432a8ce104979c019cf6d1bdded9f01e6f37a34f9344eeb3bcb9b91edbeeae2b48fa937aed66065eb7bf9231ae32e1b781000ebb6931a5e1a53363ccdbad0a932bb0a87b4ba3b14fb73465837d2e086cc8f7c3a430df7b4d632d5c0e130433475bac643b6fb5d53c84d3354bb411c2763d18e814004ace662d28d0091986beee528cb235c56e10cc97252642b4f204278ebf59670ea822d2d29de6077eff303906a74f213c6af427a6ec98361b5bbe8b5351e683a008524cc0c9c20e7f3de53dda0eff18e7ca5843ed3dcff37f3cdb086c6e3044de03681fe160d640e7364cb087e8414cd068e8e9cc5395f872ca1566d119d0cea5c1a0f282dcc3f7fbc8d92d50d4f6c1e17469715f0fc19cb13be292a0ebbe81900b40fb37a195014ca1cafdd1f647cc6430d24e570aa738e4547d582398f0ccc8917f77fedc508ee02172a58eb6b535df76eec0f60a099fba39dc94e3c29f92a3a4db9663f79d4089efac6a5950d835a73a30a30b3313474c156d5b56fe4ebf7dca1d433007942460ebd9d14c3e162fbc15f687b62eb0ae115ce11998169a2516b56949ce147cebbf17384cf609552a8e34c2e43065c35a2c51f892025e0bfd1041752bb0fc0d564d64a2b17e16e964dd6aab75fb6d54184cac16c0f9dacdd98fd46972498cb74b00a60b8368eef3cf9bd632a56c0806c4970a4488cb6be78d18c47e5c6ac8d3172feffde1d519034f25659533cb0a68629ac58e6219850cf757df6df68c4516219c250063093fabbc834df0d1ce0b72dfe91753e4d5c76871dddbbcd14b3d2f999004b421b263d461e147a2575be1522c30bef49252af41626f5114efefb9593e551697ab8cf44b9efbf42a6e4a6250c8af287fd761c9008eed75cc5b385cab9c9100147d2ba05460bb7dd958517c4f606cb8ce50f0f9cc628dc5163725c4be65aa338286b267f7d862e422ecd691022f943de0fef76052c7ba4991de275c361e7c7936e128b66f25d51dc1cf6dc1b5395c1c8c8be7c9df76030f4e5d19adace631d05da787e261092d934c1475ebb180edf434ea3b0e2f8628fce22ae53bdc141dd70d4c63562a117209671fe1ecdd44dd8f09b47e535d082e6a303bc801ffbd9f4c0bbe562c86c99d375c31b4408b7988462fd724cddc1e28cd68a74bcc7008baf7c3e77defadc350f2719eedf2ef83297ff3da48bde5aab98a76455d40097c901fecdb467f732b85760e54e34dccc199b7ceadf4ddb7aa13874ec100a6b16c8398431592501eeb41dce2902093b23459c397a02554b4292ea089f05cd890cde8d5cb9ac22eea7ea14c7e45396d97def00929022e76d60b1a051ecb7e987e4f7ee31dd7bbc4977137ff2019272cdeb9baed495ec2f794f5ef672d6192e0175d66f92d6a706958339b7a2e5bcf7227d50b78c779cbccceb5bb094783654df6eb6397f788d2b63caf85f6f045e77dc3a2fdc93f51da006a7939f4352dc460583d31a4c4c2bf3557a5a1424e8d3d927e2d02e0417276525bc49e1934955132546a2a7582c6f1f3edc420c770e6707b7bd1344022345e809942c78cec2fa1569e295fe8dcae5b60d35c9cfe1de630a71d16df522ca6e6a666c6a6ab25ad618a512ef85c3f4969e80175bdce7dd9cd8fe8ba9cc212f2870f0592d24fed0e9d681fe46b7644da44fd048d48d75523a10c02b49b380d204d8f17d0cb3416b50913540261dce94c323851cc6ad76c81434243035295e9d4a0c98ae0efb1e3d2a534f25ee7cdafc74a65b204ad18c77628b3bb4dfbaf79c614a9590ec8281edb6045867c47cf5f22fac297331bc7faf0ab6717a0a047444fa23c5b83e2f34ccdf8654beb322e2f714158882f07970a2e27c02545241eb202fb6989ad239629e3256e06764b487f14110c930cf8d870752173af5007613e98b515088456b1984928e3a1442ac55648ecfe4d0dbb6ba2514dd71a1962af1750c8843cdfe240412eaad3c6f51a07e853a4f12836384f51185c8c1f9f46f43d2ff7434eb5930ee60fd1af0bae9daa4857ee6e1f60918d96ed3c9d25b1121bfdcb1c7c19ea8c21ad7602c768008422ef6828d575f49267201ad72ce99088da1121a115f96122061813e8a78a9b0d14d0cdb5945ef0384ad486dd59d457807abef4853f905c93d78a47be871a969e101cc416896eead925bde5ce096965d1a257beeea3df32681e3f2b3da2b91ab6ca410b5d1ea5cd7909420f29642e7b1e98a9f2f14ff8534564299b95bc1c664b27fb1b0385e0e4a2ba11c686f3d2cd253bf4a0968b24a03947c4ae5e36b93dab8bf36fc8a704defb006c098b8c5526bcbf93871629b9335030a556dbad4cc041bb861f0f97b63946b870d8a36de100d4dd47344d042edeeca563f2b2d59e4e9cf28c4cba2bedbf842fb1887d0f2732596f77689559fc9cdf4bc85fe8d3fc790c4ed8e339a7cecdda05e5961c215ea234520d51d7f6dadd6f24b001eeaababc24bbd5a77282aa28e48a549fab6dc281ddc783f73ba99899406686e9c5a5a6014bc976962dec41e72ca90e8c9ff6cff8c4a65e0ae0d7f041a8eeeb52d511178c432742be6363246d26464a5bfd4f2faa59ab394775c3f88f7ffcfede74f6b952ee282b72917c6ca366141542e231cbcd712af0eae71c6b67de97437b551ae316ffdeec4a411566e58140ef13c299838eabb3cb48bb29803ce576f1784650706c1f4162457c3d3edeb0d3ac01ce674f454b9380863a3d00654febbcb47b5b78ab14609336202d35161ebae9be976ecda3e6100d7c9a4894f2e0998bee75b09d1463377d80fe74f214f9b53a2c65dd15eb7eab4dbe9482f2c1c4d0cbb4562ee579d2f5d8a8cf51a6c7e7b1f56b00fbe21d21b227469d42f1fdb1e304ecfa206efbb8fdc7cb74fc39400ab763758a8adeae1d652bffef229f79883dc477f672193cda49b21859570fdb8d17d3779ea53bed26cd79f0ef8596856c6d6dd8f6ee287bf68a8a0a6a55580d93d6b11e2561f3f62a80a6bc8305e1e14cb05ef44b27fb9e5a9206632a08976f6efd692426bdd307478b2fd24a3a7a317fa93770bb6a919b27d31e0303fb64a8824063b1ed3e5cf412fa7aa6acd64320a6f89e24851245fb9d507f1a4f6f558903ae6a2e8d6ddfbe473b9f1ff2f02568d901f97eb84f9d5e5816591bfc8bc55e8b0e75ee56dc83ae2b936361e2f4cf5a6691745a09e2b86ea2a9a38553d43dbfe9a9858e0e9fa649ba70646df8590f145e5717ffadfae6193f19eca3546ddfc264fae0e2215db36d6df23056f2f83aede504aae84952292ddc4325fa53966b78f8c7a144f67c6c99ffc832c8b7f55fc0d100c35925a5c096447eeb540a3fde3942c5092745b6a5acda9d6076f0aad12f140fbfcbecc4c36af352ad9e5ffc4f7f5b0e5f6db922da11a3cd9bbb2b91552c747a22f5b5d2cdc931fc5b538888360e48ede9dfb935f68f7dedadf365c14ba6fa497813baba643325e049da40b30daad512b5dff9f0f07f370197e178854cac6fb4a5d74ac54d5c48694133f782352f75925954bdb061f0c77109d013b87d26f14639602b4084f04dc3a61b76f9e542ff1a096587e03189a95d048267ed897525a799b3d5d02c32a6fa45f9949b32a5d09712c9043080f3487bdde85ba58132697fe0ee0c14367d13ee2c21ec214cf7ae2d0c6064b03519290d6844f0e751bafef9b341c4933fa82a614b39c002938d5d166704c02acdfefb9be69d3a79369250a5bdd0147bb70dc7ac0763c59c3e3d7545ac70c1bda04f40e90b07c0a4730d3777c264de163b4c6490de1a82b42b82228f7a6064198afc85fccf30ee09a1aeb7fd92edb2a9d6f74c05abffef38c26ef03791891894816ddfae6d393eb6513d490c1e04a55954ca8ccecfb84282f8def57ef922e50f9e09211fa0268c99ef9bfe1b021f7b897a00215e720f8d8e4aaf1c1b2e1694042212acd1469512ec0fb554e645429369a052ce94fae5a5e378d7b9fbc07702dcecc1583998fe87b3fa267a2bfa32c93f8ac42292dbb2b74148cb2e6661302908c66ba07b463d24353d855bed211d409fec27aae5a8c58ea92767a5ac6b7287d59491a74bf4e083986f56088a3f5ded09c357915406abe63bcefc289ec6c8c8c095e23e68fe87d64f521479585cd4cdc810c34a40add74416c07a8487aeefe40b69053d6e88a14a1741ea870dbfc115b7fd25c9db4547c86007c0397e82f76edeb1fbb58a33eedbea649872b26c6f51e5b8f11029535308aeed33c25fa54f0a49dc89ef46defb99ad96ee525321dfbeca20f6794c88cd5ef507bf812070191362b56fcab6e6e0a084f943e0e11ee754f2925f2e305f6a08551a4a8e9392a8ef06a0bab83c83860f73c5cc8e9cec00f2cbcc90e3e1409491355eaa0180cfec514c7ee86c88627f12bbd2a9e1bb633827678751c9df296131b4cb8464d3c69512857a1be82ea4f206a7939adb0fbd2164fb0c65c3bcbb2479aa03d5ac8c41fca35845b3a58ee54c41f7fc8d8c1e5b03bbc8f73330f5258ede32f70b610617e6999f4d8f836f22f53e2ef95203ba88f7663a13d90b359ff948e70857f5257167bc6892d8a40e6db72d3ad5204815ed76b0a1a1d38adb6df9c36c75bc94a655df055df8020073499824aeed4bf5c25279427775e306260b82eda15c0dd35c98658d22dd54eaacdb278223b6221253016c9c97c5691d26bffd06c901d34f49160ee51d7951b1553e7d0f1262074ca2f4ee2ec16b54c58edea98a904b28a14dd01e1e239fe5d8a63b3722643553f5c7786b5876ca198b6cf22076f8680a7d7a3d471f1d354b5b21907dd73c730ba8e8895e2422911672b1c419cf3ab25a066b2a7242d8f5c6b6b84feae018fc24b7f8cb2d69954309c530af2c2c7478c9638831e7442a8ae6ab4b981f42a94a0733e5e7c4ff93eeb1d38fc39c3580d1e222e165cf1cac33e3118584a844d407bc37fb01ed750ec8df053fe097913486929bfe58aba55a62f90802d8b391022b01ac587e41100fbe623a8bd19e6ab72a2e7c8cfd0b75f1e6ff8d05363bac758e130a8710f51cf5446d4376b9dd1fcb95c33d3bdc888010a8ce54b3ac9284a565db550e24d8002fef7755ef0322def97cafad70f91bd0947d18f93192a74c8a4853eb591b50abefe516397d96b26ef69de7cfc40d1f20e7665ce791a59aff3bf9e55b35125d8d4541ba47f1c5d64b9cb100d63e1f7e930e4db1ab7202d4813f764ad96a7e959523fea6cdb31190e62f6f3918e5840ef6fb285984be65d5ffed676cdff4bf6250d5e434a0ae4eaccf038b3553ad8200c45847bbdf0fcac510f9087ff8fdde33bb10245839d60b71f4547dc576479150f88170e843272434b245bd8382b5737b9a303a1d9f6fb910221aff4b7a67ce1a059cd1470b694545a480a41f617a6561292c316b95f942419db8794ec8bda3b11696091c5d4041632ded73fe22c8b38199ec0b308f374446cf86abfd0e91050e575ef2a77961fd643efdea1a7c64472afef7dc6eb4c78d39713e62ca009b60dabaaf308b5ebea0fb614958c908c59d395cdd15ecf221f7b498b36f75fb2013464d48e4812c5be5a5043ca2e43cd83c3397dc4a2f2e5e54eb307401a45012b3709c4fe0ea0881de2a4155af179c4960ba362fff1b8cc06cea6980acfc066477e519e0ef4420b4cf1176372e781cc0aa62e5a5b26079de5b81d99eb826c9c9cdd5178d181e8f791cbce55b4164e05db088dd73f09b3b75facb87107692429d6974f46dcc840fe9526ce9c51d0d60389d3be64a5fb81ae13f69c3958878272fa05e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cbcfea95816eedbf163e23f7de09d842"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
