<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Pàgina encriptada</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Pàgina encriptada</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Contrasenya"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Recorda'm
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DESENCRIPTEU" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Contrasenya incorrecta",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9613008055f70eb0066d1dc43eced94e97c78d4eb79c04867545a26082826d31375caa25de282941a080cd582f847da961a415b48279ea7f1aadc4840cb022c372571987ed1f5c1bb529b474127bad8d810f19d17ffed9f90c7210798aa2812317d8046a280bb7be6926e4110a2a63c56410342f223741b61cbe90f49ff1399c0658bff65e083e2fe659b447ed63dd5ef7d1115c955651240b4376974b89a79eab5be806c849c7b9dc946a530ef6a75deae28753f9658edf6def5675ffa867f0b006ffbf02020ad774fdd99ce07e54147c80e6d2215622b2c926194b3896b210053613df9abe8c2b2a20821f762d002496bb57bb528ca968377c8c1bf67be6f8e291bea9d64e7c8a46a0c1571a32989c222842808070d21bcbc46c100fe1eaca54e1b1c4133b7af903697295ce586fd05bc02672521081d690dd51447e88bea227f0a4a6d8870317bfa45b96c9286281f192cbc83cdc657e94bd37a956e9e018e612f713212f816426936945b60ce57db4eef39631018008d9a21e730441cba82e93cdf47d5ec99613e9018b341dd6a17df7d493163f78c52eb75b9c6685e573900af6e8f912980c55253f1e88422d01a2e07cc31f504c114b32855abf63284137e0e9ee226256fe99bec496c9a1aa9330fc55418345175702f571f5937da49ec17b754a18c7d34a34740e23465e6eda1daada9d34e3bd8716bcb849d9c28fe33ed4d5fa128f9a388ef986d237755d25a0148f4aab31ac565352fd69425ae6bb211bb408839c9ec0151d1aa0f65071f6d48b23a4e82bad429640d148572bc6247f506da4823b75551046d03dfea861fc7aefacb534f39d2412d67f4a0bcdd31a7c5c7d674b6098078ceb1b95f8811d4480799a32776eeffabb37b709d9a10aea61c8dd579109dfffba3f037b984475476801252bb257420428ab26293a6aef905f0d04703934b02a0f7b81dced2eebc4c9a36395ab7fe9b8cbe9836c6edab110eee107e86c9496581d618e62d069a610ed1b2293816cd46d90cb1dad7bbb636db53a01ff89d79cb03d5f8207a36b68e9cfd5c8793e9e816bd02a1782169db214e252a715269bb01bceaef39acfea935d75f236261dcc362527204594fbf0b2f53f3e958d43b033e18fe4a4555d3abc42e73f22aec467fd49f1b87bec26666529f31a42a2bea32a6bfdea19db243a0fec9354a9f95eb6d7c2428461f03adb6520d6a8c1a431fd4c909f281cc9643db6cd4898d33b23403998e7428841c5bf87bf5273110218337806801acf45bf202ba8e2b600e236b6d638486e188f3246880bc7724ce1eafa339193fb4f9ffda2161aef0155acdc3e6194bd3019b236306420c2be2472d38103d9592703ed4e958600c0258f9f96d684e1cc7646fc21ee4d2300b6469bbd0a14da67e7b4af4e208b64ae2a607278528bb6874466dfaeab4897d3e45cfb1e6764e40dff23cfe4dc9405ea030f6061a8510837a5c260333e5d22f58beedf710f591c0c6f0ed4a64722671c49a74ddc417d4592f8eab0f94f802cfee2257c733d0bb9e89f64e50f8bfb75d4d3b0eb46c93b1477510db90402b30c66b1bcc488dd74a984979ffe43b29e4ccd90c1037f23f9330308b2707ad2f4fd427f45245220c4b21a52a1cd169b66dcf5d2c6a234a84671e4f0c0a284f81a01215af8a0adc315750cea55055d1c6d6d173afbf5d7e2e3d17f209812fa2959fab52ee0a06e531224a69429af693959744665e82a64dd04c471bac6152ae9e72078f6e9136b8dfb831f543262532485bb5f2160c64813a19af0343ae122f40dae17dda8c025465c6683ad832e46ff404cf67f623d826d8113c60eac09b36416809ea65f8b60d37c88081c47997503a6c132ee23036a0ac7877c4c7c7d43bb3c3b01f79ac4bcc76532519b99f9fb6097f0918e745f364435ade696527b5775fadb553a1130a962ff5c8f071cfe118a41ca2f020267a2ce7244cc29438f5c13caf0bc4333b59dc9a5aa448ff648c37795cfa1b2a95bb3376ab7a8666f2aa45f45d32eba656f74c2f9c57a9faebde5b5f955662da777bd1987229d099dfe7fa9f678642bcd67c240770c00284e11f8e029c03955eea5211e5457cb534d0b24e4a40f44d8bd1a6cc095ada24dd6912376d57c08fe0a2a8ad8901b80ccfddad00c028998d9bc16223ff8dc2eea476c329f9cd141aa9f31eca866fedca35fe1c3603efa71580d5d33641e19b99f1204903f3e05a1d450042c8f2c929d9542aea6eb02437f1aa1b18697a5a98c88029d19a272d471173130722da0bab4ce84fb217c9fd22dbc2d7b19642d682c8d2d14835da0f29388e9e1144876c7da16d619e8c7d202db51d70e71bb72264583eb4808eaa018c029c09c7896be423e8ecade11b58a7d19e7afa6b73a817728088f5ac82a1bf5e8ad50a37b2cbe46aad5c719f3dcaee487798241319ad008f009a6d4d7345e0bb75145a76aec5959f3e1d02361c8d0dbdd55e165b1c046797c0668c72335fadcfd1b48b15b317a270791bdefb4e9aab3fd67f2f2faadff06c7c6f2962ef91bec00fe3600ebf391a8c4b9d457b38fdc10e676285b75e10882425b602e1b0bd159faee5712b786f0046312baabe9e886eccf4372b648581f7fd1c203fba60fe5fadbd1f24be32d0277d1ba6536ca0cb7d047ab892a286f03ec8983aaa199e5b74af87b9d09b026bd774f76183b1be2c94962d183a43401e64740e6316dca0b2377518456d09170cb2340a2e1c6d1a550eda8db15e7eb2625fae02e97b23e6e016e5e7fcd71274053f9584ce67397ce5a66e4d1e0a0d7f03bee8e7f91b9ef278364640a43bb7c6be6fcadb9427598d4caf744cf3ab7a39714e61874e40613783bd9775c70504d5b16857604ddd4c2e2cabe224238bc9cd3ec4b0fa4fd376af80bfb2dd5ab3c714e126763888b9044871f6eacf9895c2c933d7d7de057b0d954f47ef02ffa23e0f1e0fcdf9039ccf2d57667f890466f80d6566ebffbeeb995e612705f1dc270375feecd5fcc15a32c926d641392e5488d20e3e10e3e650fdf56dd93f1ee22e1ed25293e2c0c1a7746ee7aa53c6c29034c1b2658e1c1d2de0050629b2f3cdc6b96d3f74323ad6b9c9c5642b417765ac4ea4db9a2c72bc8c9c958809ce792048cbee2986a071ee134f9639486566011fd3677bcb9c53386db92ac7af087700567a2b410d3a7aca9284d13cbe00bf6ef01d3876dda8f51b701c5e4cb14dcd1765ed91d63ca91b3e14bb8d044bec0452068011fbcb625b2e75c215bac813ad853937b892a93d9fddb859f19ac8b6388fe3ed53a900354b845144790605159e5a5adb992560942546939c60c47d7a1ac3647d089259686247fd48aaaa5a354a67119f401aa7162db1b9c0fceb85eeb9ea9ea883ee955bac1fbb5feaf0b5d0400e2212b999aeda5b1cefad613fd6b48f4650f4741a7f43cd2a5438e212217478acdc65f5e80b3a0ff99219803da8a4c539ca07352241f6f011afb7f12de856440342fd9a25c230539299483d063fc0bb2efd1f93189e4b3524ad6db88c06c2188620002245a588e74d13a569fb25b49687990d2b375e47dd81a6527fe41ab8e4144b70588dd3bf1d66bdcb21eb01c1eb9f25b732dd0d8d78b6aebdc4f67c25603bc839720ea30f13baffc806b28d4ad6223dab86171ce8c1d3662aec95a55e4c7e725f0769928a91f1320909d62054e7c4c5164a853aa9471718ed5379e7521051a7e6966fde04f26ced52f144fe42348b0d53ef4084ba51091685cebdf5664597e44d2c6f8bbfc19185df7297581f2b9124546ffde3140b0fec455cc007d8fd6b9b291b562bb96c2c9466098439c11d575f373db7e2111c47a00fd5dd35273354921c0f5390e04aa5c467c4d6403e773b2b7a400bb5cad42b2c3fad7096c1596087b5bb6ccf762b2c6a66fcb818a8ce2b770f5ea3c24eb15f7de4bd170fb3b6de97da7701c7dcca3e187e79d22b7cef3a079225fad593863d087cdeac3f6800e67a97d8876a2793700fc0d3eaf69a9e20395c7f1b5fcb569f57485732a99c16ddde11923e919bd68f9787647c0a3c55e3e342a430e5851c9ff622b32eed8e79d41e37da155cbef7370d52e4aa36c803d8f4e686af79f6b317c595e5e3a212f58504949b229d71fb1d909afe77e8a49bf289b07de499eaa4a0c2202d1f6ab3345f115058088dfa70188f5d576550d1b9a3798a077ca74bd370bd93fdc0e01e30bb6c2d23ea48563a7dd996344b63557120ae5f9d8eb2604664b8b73e69204471e6c4d35418d0adddc4bbe7f893c487253700841b32bba59f9c86033a45681b20ea357f0baa6ebfc5bd74dbdd1e8cc75e9a1c854f0f93550293c4ed6a69eaa3733920d14692a367faaa7791425e3b3e9e0172e012cfbf393520cb652147da726ae8143ad7147509e9a902e6111accb81f8eb8a8f7e9ecd36390141adff38c5d63c62fe21557121b6901f7638ed6272c33e095d9512ab0ba24a7d94ebb3bd33615d06a729b5d4255b2f7ac2ff8747bac6dc0d150d15839d681dd2241c8cface8c10b80c40a8d20bb8ac35ad9015f17de7973ca34298f56fb0c1f9adb17d91121091e160d65085ae20b490314bb05e694592e97e5aa9092c08d913ff1131b55255a6b892eee9f09013387b01f1b85671c66ad43f1d71f8dc31493f883f84239b8b996c3ccc5b804bf6e3ab5fbddfab2d87590f2b9f3da1db3c9c1e02d211ebf708c2d980f1b1b2299624194642ea057ddda35a618c39e398187283c5dbb02f59e4d86eec875f2e5285d6f5b2273fe063af8f34ffed0008475f7efda7c4aa60fec3906e1683d9ee6703a0cbfb9d39f4b7be323463930d6a4b6375b34c8a4682a24f14da8902441d7d0fbe5bacc4c538d310e6465d4a47189c7726f63665a126b50aec0ee907c52c1794663f3701b1668950e80b47160decc9fd98648f7144b4576a32c38f7174978c1216495786c71d3af40608849058ddb37ac5a7b5ebabdbe358ce459da2927e4910770bb01e1cf7b170cca8bf109c984ed1621f4c83770e8ebda0b60acb44fecebdcae6d4ab0169b990bf6abde51651dfa9517c5e3f76ed637530c7877f6eba366966ae369be402560a4d0f7ef02dff155d17ada7dfcf84b582755cd0d5d2e1ef19ac4612d52934f47ec9bd47b37a014faea49e340512a53c6d772cc1f50c19ff0c4aa7e9731b0d625d0a81a5794d8fc4ecbd74898665b83f7eae6d2c92da5536bdc63bcd955cc5e7750608db172a428c02003ab1060d3b9b87511e54e621b89cfe015005c3c455ca35dbd869dfdf555bc51d1d6482d4fe3b9acf2bf2b2077351cd1620c74539caab93a554869b21873632497dbd8d1643dc0421f91d6f7425f9b44c70397a4c1b213af816b3475b296cf30922ac842d10a55b6521f37f525e729f3fb88ff8a0f9916b1da4790a4db3ccb879a73217e380616ba3b18d5303c604b774936ebebac7b7c4578ab30ae8a2be86cb68aa7002509fd502b50cee61b57b84ed738a82c02a8bf34bdb9898a8b19be1cbf884e0daddb519d210002fb34e00c064e71be29d16a08b569423cfe4a80069a9d25281a1f872df563def85845a19036381c79c2142f6543909b612c89d31f163e5aeab8b68379e9e0ae8c1c6f4d156b34dd841a86cee2c8f81e816294c4e3370e32cfa8cb9c5ffd17e7ce68bf979b850c41afc7ba252e5e4ba775c333caa8e3b8f784347b5b3ac22557588af25dfdaaed14419f57fd0b723cbe9fbf90a305a516b92c86dd03414db52db760560e3b8b01a2cf068fdd67114736edecd855fdf2718f79069a3cabad6815cec40fd9eea13264bce571cfcfa0a516aed906cdf41f47ccb7be82444d87c3575ecf9a105861497683d8f66fb64fea4546d867c71430f52017ad8f75082e4757eb6b213854ffd1fd1a02382688ec0fdf209879b816af98f9613ec204b900770d662256651f793e5c887a2400bd417fd3d9f52f295fde0e21fde55180a4eb01391d467e8b344c6e00eb9c34ccd8c5b7f4671fc8c255a69d3f344702a737e45f890a1741608969f6363922f7463bbebb82948aeb32af49d15766be9dc12f435c209540f70bb42cf5fc64fc6cbc2aef389c7ad4e77c4e9cf4b0625e5eba5fac57929d5bcced091211171994be37354abd9aeb063864e5693de1c3d0c8e2dd49b149de1e84caede933b7a1265b9887bf9f86ba2ea769a7c360dda6547b57a871af076f3434134d6eba294a03aeae0bb7582b08ef4b57e84934b7c280aca64dc4eb388af6b4a000c8ba81e6a4b0c5a934103bf3f674d762e1ce5c1145f09bea917ebcabbc17e458dcded9c86100cb835c91d9aea71d3f10edd5bb40e1fc68083347836629b11b4100e3890d97db0271a4376632709bb6ec6d008ac5d0cc8bf3cb79964f1a47bf4a077cc46783ad156a322e495247ae321f8ced144566641328f496f35920fc48ee2a41ab881ceaa0259cbf5831d68dc2c5470fc6d91ffa1cf3a32a095e504542018346ddb341d5197e78a7215e3e1f608e2e8e060f23704c596edcbb4e80fafaf32ee6cb18ee338138eaea7fc52e8d4cefec7fb11e6cc8cf56d717dc73e84ea2aeea8b53c3d91056bec03fbe271447ee4dc30c787a0731941370d1fa98dd703826b0f3fe1d1a996dabd65d39d556ac0033afb77f553ee96d5845085d9600aa290f9b742b276cb5699f1bc986bc3313e62e0e4a7da0e9517b6161cf6b78cc1dc60901dc8e0505da423917414e434f9501f891081010db0ffd5a78e7d2fa7239ea6df6a6e1a39e7e0edfbab295c15119e9635bd5577971edefc6007a0b35fe13e4c85844915f31c0ad5a03a2bd515f57483d68e3d8cce005baed124543f7bf6fc38828dec5172b4a2d543fb88818b831503aab416757340d750854631827205a7fa0e46ea8011727f8e6c4e9051f7e7e47c6fa9251d10dbf1a238e35360bc7a7559b89c28e4b134eb2628000358d4aec1ea41e601fbfc79991b4e130e486202ebb68895284b07291f4bcf69477fe9b2ad8fb3a65eb3b62137c9746b3a4ec483d27818f9c06a933911052fd42e699d56599b5ec97d526f6c936791d0427da2413cb458b3c5a35ee6a3bd45b41faa2d8fb77850d85416a6298190a0b9d37ce6d98dc5947f5e2850a07295e19c76136a997be2ee4f7c9de898c46e13328130cb616a002f8884558bb8259425b95b5159731537ac47c68f08dd4a833e543b6bd36a1daed394fb204875528e161e2e4e4b330e6204d98409d348d564f442ca4e12b76a53127663df050f509ebee68e051e9e3dbba8b7d46414c836039df5fb0170c9fbc1e7d4c5afb013baaa53ac9b5d6035f8f106cdf28dcf3d8a52d609477ece2dba189914410d7507fb7140110761e91eb5805f2e092b6b8f019a11377546007969075f828bc1d21b256163a123ba73508efd15c511e5b74588e50e215ecd2b80014dca688f9a5a9810b0c4c540605cff8c9b810d8194034614c55076c67b9d4fbc330bdd98ce41cabd122df4ef5c159074898b47f3d67c734f60f660f08080e04dece451a560c9c072992ad4fc076ad728ba343361a9c8a1423f997ab53a68dcb5597e4e0081ca67c2d1d7df3099027b2cc6e6f3303539298153f946ff1e9f7e3e0a3bfe101fcb40f5367a31c8722afd4c755fff08d33360a7225b40066dab65ef0d7b3c847520e096cb2bb4f2bf72d9b8317c71463ec4147219a8ee4e7e2abed2a6f9de6c420c23d4bb56467b8d9fb9ab7e14333d90f3bbf3a3bcd17203832d9b3427739d25cf119a116a46741b38744e0d1e180dd0a1e243b59042115fd549a67c98938a6316b035a846bf14d39080a536ddba03fce226e8a9a4dd7a7b0fdcb3b36da70815f5095a1b5a579c2d95c5f0c473ec3478c9ff7f7a719ae1da2953cb0003edc5e353fb46cfb435176c47bc247064bbd80bdf3a4a6c1f7c92474d20254be1267d0241326f811e59e007307bbbf7429e4e840fea05864b23438daf5e2a6dbb3b492518e268b53dc8d23c76df7307a1437c54fbc2b080836a1e8be64b65ab4f0b8ebd2999803cf6ad40b5900a4305c4bfb412c022e53fba9b70890bd1aff4651b694a8891383c561f3c03b6fd21ae788f54e669acc0094369de7f0f7b9ccb6d1ed9f1c9c5847fa4227852bd0c8d17f12b3cc4078264c25d3eb969f4ba059af4d24031871d147d451750cda2512e76515a70df4af1a74af3f029d00c9d1d4aa81cbbb57c7025623b94cb9cfd2c1cede3c35525466fd50eb09894d8d6fa28471d129a790c0604cac426ea77966dfef2d1206ee4215438a4f0e265c1c28c72fcce3e5380f417e5ddfffd85453d374cad2041f42b0aba9f85bb1a415e5f7ff477b89029cafec6b3b113e3da6af25b47a5da92f1e5d9f5a627981f467744df4e37a32566867295bed0dee2040f6f8470c12bb0d7e74fb37f2033fa73506b6cf9e3c2d3b9747952453b99f3bf554ecafb764de670fae64d3ddc1a4902396751a0e40c02110c5931e2b51cc36267fd558d03b4dd46bf3d8d830b9f2c252a26ee10fa01e6e6860e76ddcc7cc67a96313a870b051956bbe7308f22ce053901ea0c54aaf9f0b1c03d6af5c20dcb5550e7893ccd39af09735143fb0fb4e743a8d7caefcf5d8f4888f24fc39862ef8c53445c6f502f79a5dc61a722be23ec8f37f16a04e0176ce94ccd2d17964e9ed46a1efe892cfea5c0821fb15d2205eaeb523a5bb10b4df69273a5fa45998475f27c18f8b9a6920d5f45b9633b6afc92e2d939c59c3524d250211e6771b63e54901cf7778e6e5f31417c4fe3c975a8f0e8fc9fd2ac99ebe76641c291957b7a648b24cd6ea4ddf3b348e73886ea87ac78cfc194b3d487b65eb2eaaf5d75682d5e07516ded0cfc2fdf8464a90175202fcee9b663a70cc7a3c53cd4db47daf913c883a7788c6b3e4fbe1b68f459f1008af51d4280643f40724e9536e5aa2e0305ed0f3e2c34722a2203d187ed2b4b70a7a4247e50c93625d1d1fb5022aabbd4cd3a034e1a91410766b20e4a22861c3bc09fb17be5886f08692286d2dd014752dc4630b6ccceb94938ae5b3c726de532a59b7874d4ca1415e8575b399fe862899888ff510cf2c8073a75c8b7a72a4762a0addd981b22a77774f527e6554bf466951e8b3fa7afe0ccb1df517895ecfb98bac0f9dc11bd15451e4b1482bb00d0b4328b3c5017181e90accbbe993f179b783fe6d73b91ba6c03c47cbaedf0f4c0b9888fb2d936f06ecc58eeb5b8b3970eca9e3d32842b802eef32d8ce3ae98afaceea8f5d9b7be356188f850cb7916429253f5f4a639d0f7740c8e7d7080ad15b1bf17c55b1bcfbe22aa9359fa666b9f02955660c43b9924d47db44528670437ca7b46d89200268305e4d64a995a72c84926d81148df7a4d87749d82051b1a0fdf24b928fe6cabc6cd035db74b766643225c975366edc2ff7dea888728f4eaa0fa34f56dd550d2183e6155c5587241d00a5db0d1e233844ece9c8fad8aa2b457b5902ea932e30bcbd8e57043243a2d38972d968531d6752567edcc9641d12dfe11f8d5247299f48a1b28b4567413755b2942e159b332cbdac7941ff01e6816c1af9b06eb287b0b5ca4f019ad82d8de5a8c4e2f14c0099d40653147c2687ca04ff62e4dbe94be791352b9ac86474afcd80568ed3190ceaf7fdf70984c64c4f3e8ed24bdb119c24216a03a437621990f4c462d384d3d8eb545fae5077a5ad1629626fc2104bf25b0a7501ab2cce5965d39b721febefa3c2fa49b4c5b28bd09b7372a805a2935cf3948ac2cb7c92813ae515bc330bb37271d672f1ed20509b31afcc2d2fbee57014a7bb7e94951be50d10f694e2210fb45c3dc25e687599fe4861281f7d0a40f7a3d561f6932d4a9cbdb20ec6e949a287091a6d6cb5d0de21310c42382e318a0c822927905eec7c8b7aef6f796c32fd52629b6e346dee4a8e4f4c82cebc2f571046bdc2cede2a3f0e22f4230a591a2fd868c91abc4c2d85fba75f30f3a4c7f9e68c4c3c8aed3ea0c3825a3d2078b7d793191f333db216812afb000a439ac6e8e308ab84400fdd97d595b5c9458468f1faa24d23480f80fbbfed44319810ab874887a49cd7a160cdc303dc1b747380fd63708376469071696190c390860c8bbae458c1f9da2e7556232a9664057f8a311ddc5b214e00e65649bf84333f97518a02cefa598ac58d3855d388632d17b130e801500aabedc8480fd2d01ab2aa63784980423e8c504710f592ed4332b69c103993513d93f4c54fe75de7fa44614f4e7f53caebcf93ec18949af0dfa395937cdc212bdddf7c726ae15fcb19ffd9d54b23954e93f9d4830af5f0f7ecb5fae01a24cbc5cbc7fe037b6b77dbaa84df4e089d617c4b626b3e015800afd6fc034375df904f5593deab84ef6049a3c9fac806dd0e12caf674e88986bfe5753c02566d1b43b25a4bf8d75ed079bd199adca11baf655164dd2fb457e4dce19261263e535952258b68e52b6cc2ccb57728fdd69e7445c503e8fc15d7d10a51f5d50483edb23643824bd795d2119a9c35e37227e2ecdb4f25c27a33fce78c82442dcbd1a4c983f9eddad0bcf1d634d64960e1cbea1f6d08d3cc226efb042bf76d9b4466187e200eb3dad24167d2d1c55c1f5dc8a9d646fae7a12849a5f43d8ea4c7d77b61023bd81a4f64c4b30b0c31317c7340d2336a3c679398c688cd9487b8d4f8203d69eef3830b27942fadb801dd01278676ca28681f7734e0023740f4ab70e4dc87715d5a69d52b64d20fd3751b459ae0f14c47f2ae5836806ff2851d8ec2ef6a4289775e27d846ae5c1b4edd87ebb73afdc5fcc01c1829c73a240a2de783567a9d2614f9ee3b0c06af40e5854a2c37862c4ef0d047c51486714eda35b256369770e110454699886b4e16750b522de5da8ecb8260bf187672ae27b50c49e95d92adde4ab0f7539249cde9d0e68d98e6e2303aa1052645d78b43131a706c40046cef8f5a5e06ec66527b82942d3329a0882aba31015bbf359b7e856838297a97e2aec2eb2490da8d8dcf5cbcd3bed36ef0b1aa006a206fd871a3a000007cc0b28d81f1ada4c0cd591aaf40398d6a4aca2e1c403ff275ada3915ebb393b131b76e4336eaa95e26a8f0ebafcead05a8d31daee14db08a8e073b775b57c5deb5bcad0ee2c86bd55b2bfd4983194e70fca552ab0604c2b4921d49ccf15890f76f3df2b701d4bed4402fd6ae3e8f57f70380d82a8c5dea14845d629c7b5c6c98a46121bca0bd7170a0f30451c777afe26314aa140d19885f78d99b9e29ad7bfb401e05a8bc9330f41cf4f16c2045f32095139b7959bdb57511a5335828e93191aadbd18759ab4735f405e642feff0935452b6447c6d60d355c120a929d4bd79b286fb9d095d2c8182686bc0cfecec22a83c8f80991b3677d342f8852f06d07289b217941e6767787251195aa7d67195b96236cc8f0de372997a37aa84a9d657a0dd0ea5dafda12a9ea88352423c169dd2840291b62ef2d1a9dfeeec34f448037044cf312e27dc9477c77a7cdbaf4002cc55640741226ad38f819b2a261f37beae0e8e1bb30966747679d49da26f40fb2cdc65deb9bd13f09ebf11044bbb50c733bf9e5ff82c26bd007363772b40696e09aeccff1f08cd9d156416e1078e79b740b7646fbfd7c7f42f4337a338ebda44929fcfe5c5767521f4b5321ed3d2cf110a2ba5e83b972bfa8047214ca1c159efe114137e00a4bdab548a59a927aa04dbd0438d76c1906edb6cc925c45a4bdce98e938806413cca03c0031034816c379999442a0e1c7e339e31a0b5aa4c16d8856eeac3424f5bb61b15a7ae175796a084432b6c7813ce9d1de52706b44aa4442098bfd48c5b6989be4f2b292c1a81650df96532c851ad61a5e0ccdedca01a4c2774ba3475a7a4b65b5a5b44ef3e48c4d7d83bc8f0ec6ed18df285f9cd9827d8f9aae7b24cc18fdefc687b82c74b330144c1e467a1b16d2d02ba9644a5a840ad4ff9a4040ce8fa5469c6e6f38f27160fcff8d60bdf40d31e2c09f3d8f1ab6042d4b45a7f433fd37fd4bf49d980fd508ef6f9056c1cfa8ed3012df1389ca922abde7a26289d624e04e56008542c049336a51c1047d8fe1909238bfc61349d21bafb246c4f840610e4f6d794e2b71540d82529d014516626c8ca105ecd96f7d36877963a1c0f971d33ddaa53a999f472130f917e314a9daca5f906debb065d91f57029b0cf4eacda37b16bf0540cb5a2076eb87bfe807a10353d24a44b604449d59046284c68f905bfe3c85f1c61776331accdc1474bdcfd87cf144ee9ef203a149570d9ec35f71f7ba24bce045778205f60d826f7d5efd4181b69489cc9e4940773a7b0da8b5523753baebe35b0c22c920e6a4511da6ae58921ad26504a979448b198e7e3c42f74a41a21b3c25af2c221bfcbd33de87da3d1c0b990e2d87307d5b0b999917397690d915e9fcf01644deb090ecccc0af08445786539f91b7873fa0f4adb8b1ebded6e03c633c554bac93739289fd40e24e286e7c2cb04113ee2f8c553cf21c1843901cf982e890476584a248fc997bc4c5928735421039647eb943c35e2d9e22e546ae93735fcf769e07f452542bc2e150539492a7e8dd8ca9a9945c6e2f3c8e89ba81c15f0d4ee683fdfc039a27b601bd38ddd40b0e98d9307df54e54b1eb8ba055b49484da88c339d4aabfcfbe89361d3b31ff28668161ffa5ec5f211ef0dcef66eedbba231847b556cab6d65f597011d0b19f6d12a34b29bfae13454b389fab11d0052cd92d4768a74af07fc8ed7614c176fbbaaf6a6f5bb1870ad4f091734b8bc39628fba21bf522f83c24d63b27e8f6d806852f3ccf121100f554c32fe9563285e772cc369253a07829957d369f9d9455cda8cc199a9be789338d7c1be67a3a89e1b4da71a14a1cf5a1c9a87fac339edb4c885a7680e108165bb73b9c1de3165a435c0ce641c849282d89af2f2916f96ccc66ce346fcba2a8c4e454f01f2fdcf0d2379044b5679fa10fe1265d29d80bd2fca4cf9cc329a9a09b8ba88f09cd16f34675ca6286793970736eb9cee1d062ce64860cae037d64d720a4466ffa3bf58e22ffbf262f0cccc8e5cd70b79c1ba87a01765d1b40b575929f3eaace63a97efaba59f9568f4d82476b1a2d78b36cb0fc1e9854d1239e65be233dd4205021b0770fc8ce89cc92d3565dcfa5e772334d0e63d61285b77d8b897f5e60dac3df1c15dc865e71878adcc650185f40ba4d291816d65429538b97665b596c6ebbb033a3d99533868d5d41c7cc8db7a0aa7c1548c5df3d2c7a1ab1a6d36f256ef7340036c5c620aca2d27d3159ec4c0450e3971f546f0c12c3e3b484ff3aaea26950929fd977deeb1fc8a94924db040aa1d71ee71a41ad97a199d97aca74534224f616676e72b94f3ac0c03dece6a958cd6282fae4cf0ce57970a9dabfb71dfd3fb0ddb193360828eaf590624dd0bf3348538cea1ca476557597d275def2a83c3b11b953a64f10d348c41a5fa60c8f8409b786b99ac125eb0478dacbe4e949616d60bd3046495016424fe874e67915c9af09b58e1a0807b3ed2946af4f8d8be1edf4e4be84aa560a5e2ac94bc5ac4bddf9514c281ba380382de9d6f62864c873323bdc759dca747f34eccfd52341d787c53f57ca48215d18389baf64f30d04de603b54f58326e0df7f239ec388cd03c7bdc016b9916d0fac4390c35efbbc15a6eca0933f6a28dcb738bf0994b87a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cbcfea95816eedbf163e23f7de09d842"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
